
<html>
    <head>
        <title>Coverage Report</title>
        
        <style type="text/css">
            body { background-color: #fff; }
            table {
                margin-left: 10px;
                border-collapse: collapse;
            }
            td { 
                background-color: #fff; 
                padding: 2px;
            }
            table.overview td {
                padding-right: 20px;
            }
            td.percent, td.linecount { text-align: right; }
            div.package, #totalcov { 
                position: fixed;
                color: #fff;
                background-color: #375eab; 
                font-size: 16px;
                font-weight: bold;
                padding: 10px;
                border-radius: 5px 5px 5px 5px;
            }
            div.package, #totalcov { 
                float: right; 
                right: 10px;
            }
            #totalcov { 
                background-color: #fff;
                color: #000;
                border: 1px solid #375eab;
                clear: both;
            }
            div.package {
                top: 10px;
            }
            #doctitle { 
                background-color: #fff; 
                font-size: 24px;
                margin-top: 20px;
                margin-left: 10px;
                color: #375eab;
                font-weight: bold;
            }
            #about {
                margin-left: 18px;
                font-size: 10px;
            }
            table tr:last-child td {
                font-weight: bold;
            }
            .functitle, .funcname { 
                text-align: center; 
                font-size: 20px; 
                font-weight: bold; 
                color: 375eab; 
            }
            .funcname {
                text-align: left;
                margin-top: 20px;
                margin-left: 10px;
                margin-bottom: 20px;
                padding: 2px 5px 5px;
                background-color: #e0ebf5;
            }
            table.listing {
                margin-left: 10px;
            }
            table.listing td {
                padding: 0px;
                font-size: 12px;
                background-color: #eee; 
                vertical-align: top;
                padding-left: 10px;
                border-bottom: 1px solid #fff;
            }
            table.listing td:first-child {
                text-align: right;
                font-weight: bold;
                vertical-align: center;
            }
            table.listing tr.miss td {
                background-color: #FFBBB8;
            }
            table.listing tr:last-child td {
                font-weight: normal;
                color: #000;
            }
            table.listing tr:last-child td:first-child {
                font-weight: bold;
            }
            .info {
                margin-left: 10px;
            }
            .info code {
            }
            pre { margin: 1px; }
            pre.cmd { 
                background-color: #e9e9e9;
                border-radius: 5px 5px 5px 5px;
                padding: 10px;
                margin: 20px;
                line-height: 18px;
                font-size; 14px;
            }
            a { 
                text-decoration: none; 
                color: #375eab;
            }
            a:hover { text-decoration: underline; }
            p { margin-left: 10px; }
        </style>
        
    </head>
    <body>
        <div id="doctitle">Coverage Report</div>
    <div id="about">Generated on 24 Nov 13 18:01 -0800 with <a href="https://github.com/matm/gocov-html">gocov-html</a></div><div class="package">github.com/ricallinson/stackr</div>
<div id="totalcov">github.com/ricallinson/stackr</div>
<div class="funcname">Overview</div><p>This is a coverage report created after analysis of the <code>github.com/ricallinson/stackr</code> package. It 
        has been generated with the following command:</p><pre class="cmd">gocov test github.com/ricallinson/stackr | gocov-html</pre>        <p>Here are the stats. Please select a function name to view its implementation and see what's left for testing.</p><table class="overview">
<tr id="s_fn_Favicon"><td><code><a href="#fn_Favicon">Favicon(...)</a></code></td><td><code>github.com/ricallinson/stackr/favicon.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>38/38</code></td></tr>
<tr id="s_fn_ErrorHandler"><td><code><a href="#fn_ErrorHandler">ErrorHandler(...)</a></code></td><td><code>github.com/ricallinson/stackr/error_handler.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>20/20</code></td></tr>
<tr id="s_fn_Logger"><td><code><a href="#fn_Logger">Logger(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>19/19</code></td></tr>
<tr id="s_fn_loggerFormatDev"><td><code><a href="#fn_loggerFormatDev">loggerFormatDev(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>18/18</code></td></tr>
<tr id="s_fn_loggerFormat"><td><code><a href="#fn_loggerFormat">loggerFormat(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>8/8</code></td></tr>
<tr id="s_fn_Response.Write"><td><code><a href="#fn_Response.Write">Response.Write(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>8/8</code></td></tr>
<tr id="s_fn_MethodOverride"><td><code><a href="#fn_MethodOverride">MethodOverride(...)</a></code></td><td><code>github.com/ricallinson/stackr/method_override.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>7/7</code></td></tr>
<tr id="s_fn_ResponseTime"><td><code><a href="#fn_ResponseTime">ResponseTime(...)</a></code></td><td><code>github.com/ricallinson/stackr/response_time.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>6/6</code></td></tr>
<tr id="s_fn_Response.WriteBytes"><td><code><a href="#fn_Response.WriteBytes">Response.WriteBytes(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>6/6</code></td></tr>
<tr id="s_fn_Response.SetHeader"><td><code><a href="#fn_Response.SetHeader">Response.SetHeader(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>5/5</code></td></tr>
<tr id="s_fn_CreateServer"><td><code><a href="#fn_CreateServer">CreateServer(...)</a></code></td><td><code>github.com/ricallinson/stackr/stackr.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>5/5</code></td></tr>
<tr id="s_fn_supportsMethod"><td><code><a href="#fn_supportsMethod">supportsMethod(...)</a></code></td><td><code>github.com/ricallinson/stackr/method_override.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>5/5</code></td></tr>
<tr id="s_fn_Response.SetHeaders"><td><code><a href="#fn_Response.SetHeaders">Response.SetHeaders(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>4/4</code></td></tr>
<tr id="s_fn_Response.End"><td><code><a href="#fn_Response.End">Response.End(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>4/4</code></td></tr>
<tr id="s_fn_createRequest"><td><code><a href="#fn_createRequest">createRequest(...)</a></code></td><td><code>github.com/ricallinson/stackr/request.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>4/4</code></td></tr>
<tr id="s_fn_@42:26"><td><code><a href="#fn_@42:26">@42:26(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>4/4</code></td></tr>
<tr id="s_fn_Response.Emit"><td><code><a href="#fn_Response.Emit">Response.Emit(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>4/4</code></td></tr>
<tr id="s_fn_Response.writeHeaders"><td><code><a href="#fn_Response.writeHeaders">Response.writeHeaders(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>3/3</code></td></tr>
<tr id="s_fn_createResponse"><td><code><a href="#fn_createResponse">createResponse(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>2/2</code></td></tr>
<tr id="s_fn_Response.On"><td><code><a href="#fn_Response.On">Response.On(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@118:13"><td><code><a href="#fn_@118:13">@118:13(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@110:17"><td><code><a href="#fn_@110:17">@110:17(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@102:15"><td><code><a href="#fn_@102:15">@102:15(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_Response.RemoveHeader"><td><code><a href="#fn_Response.RemoveHeader">Response.RemoveHeader(...)</a></code></td><td><code>github.com/ricallinson/stackr/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@94:10"><td><code><a href="#fn_@94:10">@94:10(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@86:13"><td><code><a href="#fn_@86:13">@86:13(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@78:11"><td><code><a href="#fn_@78:11">@78:11(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@70:18"><td><code><a href="#fn_@70:18">@70:18(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@62:20"><td><code><a href="#fn_@62:20">@62:20(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_@54:19"><td><code><a href="#fn_@54:19">@54:19(...)</a></code></td><td><code>github.com/ricallinson/stackr/logger.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_Server.Handle"><td><code><a href="#fn_Server.Handle">Server.Handle(...)</a></code></td><td><code>github.com/ricallinson/stackr/stackr.go</code></td><td class="percent"><code>96.55%</code></td><td class="linecount"><code>28/29</code></td></tr>
<tr id="s_fn_Server.Use"><td><code><a href="#fn_Server.Use">Server.Use(...)</a></code></td><td><code>github.com/ricallinson/stackr/stackr.go</code></td><td class="percent"><code>92.31%</code></td><td class="linecount"><code>12/13</code></td></tr>
<tr id="s_fn_Static"><td><code><a href="#fn_Static">Static(...)</a></code></td><td><code>github.com/ricallinson/stackr/static.go</code></td><td class="percent"><code>92.00%</code></td><td class="linecount"><code>23/25</code></td></tr>
<tr id="s_fn_Server.Listen"><td><code><a href="#fn_Server.Listen">Server.Listen(...)</a></code></td><td><code>github.com/ricallinson/stackr/stackr.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/2</code></td></tr>
<tr id="s_fn_Server.ListenTLS"><td><code><a href="#fn_Server.ListenTLS">Server.ListenTLS(...)</a></code></td><td><code>github.com/ricallinson/stackr/stackr.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/2</code></td></tr>
<tr id="s_fn_Server.ServeHTTP"><td><code><a href="#fn_Server.ServeHTTP">Server.ServeHTTP(...)</a></code></td><td><code>github.com/ricallinson/stackr/stackr.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/1</code></td></tr>
<tr><td colspan="2"><code>github.com/ricallinson/stackr</code></td><td class="percent"><code>96.44%</code></td><td class="linecount"><code>244/253</code></td></tr>
</table>

<div class="funcname" id="fn_Favicon">func Favicon</div><div class="info"><a href="#s_fn_Favicon">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/favicon.go</code>:</p></div><table class="listing">
<tr><td>43</td><td><code><pre>func Favicon(o ...map[string]string) func(*Request, *Response, func()) {</pre></code></td></tr><tr><td>44</td><td><code><pre></pre></code></td></tr><tr><td>45</td><td><code><pre>        /*</pre></code></td></tr><tr><td>46</td><td><code><pre>           If we got options use them.</pre></code></td></tr><tr><td>47</td><td><code><pre>        */</pre></code></td></tr><tr><td>48</td><td><code><pre></pre></code></td></tr><tr><td>49</td><td><code><pre>        opt := faviconOpt{}</pre></code></td></tr><tr><td>50</td><td><code><pre></pre></code></td></tr><tr><td>51</td><td><code><pre>        if len(o) == 1 {</pre></code></td></tr><tr><td>52</td><td><code><pre>                val := o[0]</pre></code></td></tr><tr><td>53</td><td><code><pre>                opt.Path = val[&#34;path&#34;]</pre></code></td></tr><tr><td>54</td><td><code><pre>                opt.MaxAge, _ = strconv.Atoi(val[&#34;maxage&#34;])</pre></code></td></tr><tr><td>55</td><td><code><pre>        }</pre></code></td></tr><tr><td>56</td><td><code><pre></pre></code></td></tr><tr><td>57</td><td><code><pre>        /*</pre></code></td></tr><tr><td>58</td><td><code><pre>           Create an Icon.</pre></code></td></tr><tr><td>59</td><td><code><pre>        */</pre></code></td></tr><tr><td>60</td><td><code><pre></pre></code></td></tr><tr><td>61</td><td><code><pre>        type Icon struct {</pre></code></td></tr><tr><td>62</td><td><code><pre>                headers map[string]string</pre></code></td></tr><tr><td>63</td><td><code><pre>                body    []byte</pre></code></td></tr><tr><td>64</td><td><code><pre>        }</pre></code></td></tr><tr><td>65</td><td><code><pre></pre></code></td></tr><tr><td>66</td><td><code><pre>        /*</pre></code></td></tr><tr><td>67</td><td><code><pre>           Create a new map.</pre></code></td></tr><tr><td>68</td><td><code><pre>        */</pre></code></td></tr><tr><td>69</td><td><code><pre></pre></code></td></tr><tr><td>70</td><td><code><pre>        icon := Icon{</pre></code></td></tr><tr><td>71</td><td><code><pre>                headers: make(map[string]string),</pre></code></td></tr><tr><td>72</td><td><code><pre>        }</pre></code></td></tr><tr><td>73</td><td><code><pre></pre></code></td></tr><tr><td>74</td><td><code><pre>        /*</pre></code></td></tr><tr><td>75</td><td><code><pre>           Set the default maxAge.</pre></code></td></tr><tr><td>76</td><td><code><pre>        */</pre></code></td></tr><tr><td>77</td><td><code><pre></pre></code></td></tr><tr><td>78</td><td><code><pre>        maxAge := 86400000</pre></code></td></tr><tr><td>79</td><td><code><pre></pre></code></td></tr><tr><td>80</td><td><code><pre>        /*</pre></code></td></tr><tr><td>81</td><td><code><pre>           If we were given a max age use it.</pre></code></td></tr><tr><td>82</td><td><code><pre>        */</pre></code></td></tr><tr><td>83</td><td><code><pre></pre></code></td></tr><tr><td>84</td><td><code><pre>        if opt.MaxAge &gt; 0 {</pre></code></td></tr><tr><td>85</td><td><code><pre>                maxAge = opt.MaxAge</pre></code></td></tr><tr><td>86</td><td><code><pre>        }</pre></code></td></tr><tr><td>87</td><td><code><pre></pre></code></td></tr><tr><td>88</td><td><code><pre>        /*</pre></code></td></tr><tr><td>89</td><td><code><pre>           Set the default path.</pre></code></td></tr><tr><td>90</td><td><code><pre>        */</pre></code></td></tr><tr><td>91</td><td><code><pre></pre></code></td></tr><tr><td>92</td><td><code><pre>        path := &#34;./favicon.ico&#34;</pre></code></td></tr><tr><td>93</td><td><code><pre></pre></code></td></tr><tr><td>94</td><td><code><pre>        /*</pre></code></td></tr><tr><td>95</td><td><code><pre>           If we were given a path use it.</pre></code></td></tr><tr><td>96</td><td><code><pre>        */</pre></code></td></tr><tr><td>97</td><td><code><pre></pre></code></td></tr><tr><td>98</td><td><code><pre>        if len(opt.Path) &gt; 0 {</pre></code></td></tr><tr><td>99</td><td><code><pre>                path = opt.Path</pre></code></td></tr><tr><td>100</td><td><code><pre>        }</pre></code></td></tr><tr><td>101</td><td><code><pre></pre></code></td></tr><tr><td>102</td><td><code><pre>        /*</pre></code></td></tr><tr><td>103</td><td><code><pre>           The Handler function returned to Use().</pre></code></td></tr><tr><td>104</td><td><code><pre>        */</pre></code></td></tr><tr><td>105</td><td><code><pre></pre></code></td></tr><tr><td>106</td><td><code><pre>        return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>107</td><td><code><pre></pre></code></td></tr><tr><td>108</td><td><code><pre>                /*</pre></code></td></tr><tr><td>109</td><td><code><pre>                   If this is not a fav icon return fast</pre></code></td></tr><tr><td>110</td><td><code><pre>                */</pre></code></td></tr><tr><td>111</td><td><code><pre></pre></code></td></tr><tr><td>112</td><td><code><pre>                if req.OriginalUrl != &#34;/favicon.ico&#34; {</pre></code></td></tr><tr><td>113</td><td><code><pre>                        next()</pre></code></td></tr><tr><td>114</td><td><code><pre>                        return</pre></code></td></tr><tr><td>115</td><td><code><pre>                }</pre></code></td></tr><tr><td>116</td><td><code><pre></pre></code></td></tr><tr><td>117</td><td><code><pre>                /*</pre></code></td></tr><tr><td>118</td><td><code><pre>                   If we have the icon cached, serve it.</pre></code></td></tr><tr><td>119</td><td><code><pre>                */</pre></code></td></tr><tr><td>120</td><td><code><pre></pre></code></td></tr><tr><td>121</td><td><code><pre>                if len(icon.body) &gt; 0 {</pre></code></td></tr><tr><td>122</td><td><code><pre>                        res.SetHeaders(icon.headers)</pre></code></td></tr><tr><td>123</td><td><code><pre>                        res.WriteBytes(icon.body)</pre></code></td></tr><tr><td>124</td><td><code><pre>                        res.End(&#34;&#34;)</pre></code></td></tr><tr><td>125</td><td><code><pre>                        next()</pre></code></td></tr><tr><td>126</td><td><code><pre>                        return</pre></code></td></tr><tr><td>127</td><td><code><pre>                }</pre></code></td></tr><tr><td>128</td><td><code><pre></pre></code></td></tr><tr><td>129</td><td><code><pre>                /*</pre></code></td></tr><tr><td>130</td><td><code><pre>                   Otherwise read the icon into cache.</pre></code></td></tr><tr><td>131</td><td><code><pre>                */</pre></code></td></tr><tr><td>132</td><td><code><pre></pre></code></td></tr><tr><td>133</td><td><code><pre>                buf, err := ioutil.ReadFile(path)</pre></code></td></tr><tr><td>134</td><td><code><pre>                if err != nil {</pre></code></td></tr><tr><td>135</td><td><code><pre>                        fmt.Println(err)</pre></code></td></tr><tr><td>136</td><td><code><pre>                        next()</pre></code></td></tr><tr><td>137</td><td><code><pre>                        return</pre></code></td></tr><tr><td>138</td><td><code><pre>                }</pre></code></td></tr><tr><td>139</td><td><code><pre></pre></code></td></tr><tr><td>140</td><td><code><pre>                /*</pre></code></td></tr><tr><td>141</td><td><code><pre>                   Generate an MD5 of the icon to be used in the etag.</pre></code></td></tr><tr><td>142</td><td><code><pre>                */</pre></code></td></tr><tr><td>143</td><td><code><pre></pre></code></td></tr><tr><td>144</td><td><code><pre>                hasher := md5.New()</pre></code></td></tr><tr><td>145</td><td><code><pre>                io.WriteString(hasher, fmt.Sprint(buf))</pre></code></td></tr><tr><td>146</td><td><code><pre></pre></code></td></tr><tr><td>147</td><td><code><pre>                /*</pre></code></td></tr><tr><td>148</td><td><code><pre>                   Create headers for the icon.</pre></code></td></tr><tr><td>149</td><td><code><pre>                */</pre></code></td></tr><tr><td>150</td><td><code><pre></pre></code></td></tr><tr><td>151</td><td><code><pre>                icon.headers[&#34;content-type&#34;] = &#34;image/x-icon&#34;</pre></code></td></tr><tr><td>152</td><td><code><pre>                icon.headers[&#34;content-length&#34;] = fmt.Sprint(len(buf))</pre></code></td></tr><tr><td>153</td><td><code><pre>                icon.headers[&#34;etag&#34;] = fmt.Sprint(hasher.Sum(nil))</pre></code></td></tr><tr><td>154</td><td><code><pre>                icon.headers[&#34;cache-control&#34;] = &#34;public, max-age=&#34; + fmt.Sprint(maxAge/1000)</pre></code></td></tr><tr><td>155</td><td><code><pre>                icon.body = buf</pre></code></td></tr><tr><td>156</td><td><code><pre></pre></code></td></tr><tr><td>157</td><td><code><pre>                /*</pre></code></td></tr><tr><td>158</td><td><code><pre>                   Serve the icon.</pre></code></td></tr><tr><td>159</td><td><code><pre>                */</pre></code></td></tr><tr><td>160</td><td><code><pre></pre></code></td></tr><tr><td>161</td><td><code><pre>                res.SetHeaders(icon.headers)</pre></code></td></tr><tr><td>162</td><td><code><pre>                res.WriteBytes(icon.body)</pre></code></td></tr><tr><td>163</td><td><code><pre>                res.End(&#34;&#34;)</pre></code></td></tr><tr><td>164</td><td><code><pre>        }</pre></code></td></tr><tr><td>165</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_ErrorHandler">func ErrorHandler</div><div class="info"><a href="#s_fn_ErrorHandler">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/error_handler.go</code>:</p></div><table class="listing">
<tr><td>18</td><td><code><pre>func ErrorHandler(t ...string) func(*Request, *Response, func()) {</pre></code></td></tr><tr><td>19</td><td><code><pre></pre></code></td></tr><tr><td>20</td><td><code><pre>        title := &#34;Forgery&#34;</pre></code></td></tr><tr><td>21</td><td><code><pre></pre></code></td></tr><tr><td>22</td><td><code><pre>        if len(t) == 1 {</pre></code></td></tr><tr><td>23</td><td><code><pre>                title = t[0]</pre></code></td></tr><tr><td>24</td><td><code><pre>        }</pre></code></td></tr><tr><td>25</td><td><code><pre></pre></code></td></tr><tr><td>26</td><td><code><pre>        return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>27</td><td><code><pre>                // Call next as we&#39;re going to wait for an error.</pre></code></td></tr><tr><td>28</td><td><code><pre>                next()</pre></code></td></tr><tr><td>29</td><td><code><pre>                // If there is no error then return.</pre></code></td></tr><tr><td>30</td><td><code><pre>                if res.Error == nil {</pre></code></td></tr><tr><td>31</td><td><code><pre>                        return</pre></code></td></tr><tr><td>32</td><td><code><pre>                }</pre></code></td></tr><tr><td>33</td><td><code><pre>                // Otherwise...</pre></code></td></tr><tr><td>34</td><td><code><pre>                // Reset the status code to a general error.</pre></code></td></tr><tr><td>35</td><td><code><pre>                if res.StatusCode &lt; 400 {</pre></code></td></tr><tr><td>36</td><td><code><pre>                        res.StatusCode = 500</pre></code></td></tr><tr><td>37</td><td><code><pre>                }</pre></code></td></tr><tr><td>38</td><td><code><pre>                // html</pre></code></td></tr><tr><td>39</td><td><code><pre>                if strings.Index(req.Header.Get(&#34;Accept&#34;), &#34;html&#34;) &gt; 0 {</pre></code></td></tr><tr><td>40</td><td><code><pre>                        res.SetHeader(&#34;Content-Type&#34;, &#34;text/html; charset=utf-8&#34;)</pre></code></td></tr><tr><td>41</td><td><code><pre>                        res.End(&#34;&lt;html&gt;&lt;head&gt;&lt;meta charset=\&#34;utf-8\&#34;&gt;&lt;title&gt;&#34; +</pre></code></td></tr><tr><td>42</td><td><code><pre>                                fmt.Sprint(res.Error) + &#34;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;&#34; + title + &#34;&lt;/h1&gt;&lt;h2&gt;&lt;em&gt;&#34; +</pre></code></td></tr><tr><td>43</td><td><code><pre>                                fmt.Sprint(res.StatusCode) + &#34;&lt;/em&gt; &#34; +</pre></code></td></tr><tr><td>44</td><td><code><pre>                                fmt.Sprint(res.Error) + &#34;&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;&lt;/h1&gt;&#34;)</pre></code></td></tr><tr><td>45</td><td><code><pre>                        return</pre></code></td></tr><tr><td>46</td><td><code><pre>                }</pre></code></td></tr><tr><td>47</td><td><code><pre>                // json</pre></code></td></tr><tr><td>48</td><td><code><pre>                if strings.Index(req.Header.Get(&#34;Accept&#34;), &#34;json&#34;) &gt; 0 {</pre></code></td></tr><tr><td>49</td><td><code><pre>                        res.SetHeader(&#34;Content-Type&#34;, &#34;application/json&#34;)</pre></code></td></tr><tr><td>50</td><td><code><pre>                        j, _ := json.Marshal(map[string]string{</pre></code></td></tr><tr><td>51</td><td><code><pre>                                &#34;code&#34;:  fmt.Sprint(res.StatusCode),</pre></code></td></tr><tr><td>52</td><td><code><pre>                                &#34;error&#34;: fmt.Sprint(res.Error),</pre></code></td></tr><tr><td>53</td><td><code><pre>                        })</pre></code></td></tr><tr><td>54</td><td><code><pre>                        res.WriteBytes(j)</pre></code></td></tr><tr><td>55</td><td><code><pre>                        return</pre></code></td></tr><tr><td>56</td><td><code><pre>                }</pre></code></td></tr><tr><td>57</td><td><code><pre>                // plain text</pre></code></td></tr><tr><td>58</td><td><code><pre>                res.SetHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;)</pre></code></td></tr><tr><td>59</td><td><code><pre>                res.End(fmt.Sprint(res.Error))</pre></code></td></tr><tr><td>60</td><td><code><pre>        }</pre></code></td></tr><tr><td>61</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Logger">func Logger</div><div class="info"><a href="#s_fn_Logger">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>168</td><td><code><pre>func Logger(o ...interface{}) func(*Request, *Response, func()) {</pre></code></td></tr><tr><td>169</td><td><code><pre></pre></code></td></tr><tr><td>170</td><td><code><pre>        /*</pre></code></td></tr><tr><td>171</td><td><code><pre>           If we got options use them.</pre></code></td></tr><tr><td>172</td><td><code><pre>        */</pre></code></td></tr><tr><td>173</td><td><code><pre></pre></code></td></tr><tr><td>174</td><td><code><pre>        opt := loggerOpt{}</pre></code></td></tr><tr><td>175</td><td><code><pre></pre></code></td></tr><tr><td>176</td><td><code><pre>        // The first argument is the map of options.</pre></code></td></tr><tr><td>177</td><td><code><pre>        if len(o) &gt; 0 {</pre></code></td></tr><tr><td>178</td><td><code><pre>                val := o[0].(map[string]string)</pre></code></td></tr><tr><td>179</td><td><code><pre>                opt.format = val[&#34;format&#34;]</pre></code></td></tr><tr><td>180</td><td><code><pre>                // opt.buffer = strconv.Atoi(val[&#34;buffer&#34;])</pre></code></td></tr><tr><td>181</td><td><code><pre>                opt.immediate = val[&#34;immediate&#34;] == &#34;true&#34;</pre></code></td></tr><tr><td>182</td><td><code><pre>        }</pre></code></td></tr><tr><td>183</td><td><code><pre></pre></code></td></tr><tr><td>184</td><td><code><pre>        // The second argument is the writer function.</pre></code></td></tr><tr><td>185</td><td><code><pre>        if len(o) == 2 {</pre></code></td></tr><tr><td>186</td><td><code><pre>                val := o[1].(func(...interface{}) (int, error))</pre></code></td></tr><tr><td>187</td><td><code><pre>                opt.writer = val</pre></code></td></tr><tr><td>188</td><td><code><pre>        }</pre></code></td></tr><tr><td>189</td><td><code><pre></pre></code></td></tr><tr><td>190</td><td><code><pre>        /*</pre></code></td></tr><tr><td>191</td><td><code><pre>           If we were not given a format use &#34;default&#34;.</pre></code></td></tr><tr><td>192</td><td><code><pre>        */</pre></code></td></tr><tr><td>193</td><td><code><pre></pre></code></td></tr><tr><td>194</td><td><code><pre>        if opt.format == &#34;&#34; {</pre></code></td></tr><tr><td>195</td><td><code><pre>                opt.format = &#34;default&#34;</pre></code></td></tr><tr><td>196</td><td><code><pre>        }</pre></code></td></tr><tr><td>197</td><td><code><pre></pre></code></td></tr><tr><td>198</td><td><code><pre>        /*</pre></code></td></tr><tr><td>199</td><td><code><pre>           Set the default stream.</pre></code></td></tr><tr><td>200</td><td><code><pre>        */</pre></code></td></tr><tr><td>201</td><td><code><pre></pre></code></td></tr><tr><td>202</td><td><code><pre>        logWriter := fmt.Println</pre></code></td></tr><tr><td>203</td><td><code><pre></pre></code></td></tr><tr><td>204</td><td><code><pre>        /*</pre></code></td></tr><tr><td>205</td><td><code><pre>           If we were given a different stream use that.</pre></code></td></tr><tr><td>206</td><td><code><pre>        */</pre></code></td></tr><tr><td>207</td><td><code><pre></pre></code></td></tr><tr><td>208</td><td><code><pre>        if opt.writer != nil {</pre></code></td></tr><tr><td>209</td><td><code><pre>                logWriter = opt.writer</pre></code></td></tr><tr><td>210</td><td><code><pre>        }</pre></code></td></tr><tr><td>211</td><td><code><pre></pre></code></td></tr><tr><td>212</td><td><code><pre>        /*</pre></code></td></tr><tr><td>213</td><td><code><pre>           Output on request instead of response.</pre></code></td></tr><tr><td>214</td><td><code><pre>        */</pre></code></td></tr><tr><td>215</td><td><code><pre></pre></code></td></tr><tr><td>216</td><td><code><pre>        immediate := opt.immediate</pre></code></td></tr><tr><td>217</td><td><code><pre></pre></code></td></tr><tr><td>218</td><td><code><pre>        /*</pre></code></td></tr><tr><td>219</td><td><code><pre>           Return the Handler function.</pre></code></td></tr><tr><td>220</td><td><code><pre>        */</pre></code></td></tr><tr><td>221</td><td><code><pre></pre></code></td></tr><tr><td>222</td><td><code><pre>        return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>223</td><td><code><pre></pre></code></td></tr><tr><td>224</td><td><code><pre>                /*</pre></code></td></tr><tr><td>225</td><td><code><pre>                   Grab the start time.</pre></code></td></tr><tr><td>226</td><td><code><pre>                */</pre></code></td></tr><tr><td>227</td><td><code><pre></pre></code></td></tr><tr><td>228</td><td><code><pre>                opt.startTime = time.Now().UnixNano()</pre></code></td></tr><tr><td>229</td><td><code><pre></pre></code></td></tr><tr><td>230</td><td><code><pre>                /*</pre></code></td></tr><tr><td>231</td><td><code><pre>                   If we are to log at the end of the request call next() now.</pre></code></td></tr><tr><td>232</td><td><code><pre>                */</pre></code></td></tr><tr><td>233</td><td><code><pre></pre></code></td></tr><tr><td>234</td><td><code><pre>                if immediate == false {</pre></code></td></tr><tr><td>235</td><td><code><pre></pre></code></td></tr><tr><td>236</td><td><code><pre>                        /*</pre></code></td></tr><tr><td>237</td><td><code><pre>                           Once all the other middleware has run, execution</pre></code></td></tr><tr><td>238</td><td><code><pre>                           will come back to this point and continue.</pre></code></td></tr><tr><td>239</td><td><code><pre>                        */</pre></code></td></tr><tr><td>240</td><td><code><pre></pre></code></td></tr><tr><td>241</td><td><code><pre>                        next()</pre></code></td></tr><tr><td>242</td><td><code><pre>                }</pre></code></td></tr><tr><td>243</td><td><code><pre></pre></code></td></tr><tr><td>244</td><td><code><pre>                /*</pre></code></td></tr><tr><td>245</td><td><code><pre>                   Format the log string requested and write it to the stream function.</pre></code></td></tr><tr><td>246</td><td><code><pre>                */</pre></code></td></tr><tr><td>247</td><td><code><pre></pre></code></td></tr><tr><td>248</td><td><code><pre>                logWriter(loggerFormat(opt, req, res, opt.format))</pre></code></td></tr><tr><td>249</td><td><code><pre>        }</pre></code></td></tr><tr><td>250</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_loggerFormatDev">func loggerFormatDev</div><div class="info"><a href="#s_fn_loggerFormatDev">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>299</td><td><code><pre>func loggerFormatDev(opt loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>300</td><td><code><pre></pre></code></td></tr><tr><td>301</td><td><code><pre>        /*</pre></code></td></tr><tr><td>302</td><td><code><pre>           Get the length of the data sent.</pre></code></td></tr><tr><td>303</td><td><code><pre>        */</pre></code></td></tr><tr><td>304</td><td><code><pre></pre></code></td></tr><tr><td>305</td><td><code><pre>        length, _ := strconv.Atoi(loggerFormatFunctions[&#34;:res[content-length]&#34;](&amp;opt, req, res))</pre></code></td></tr><tr><td>306</td><td><code><pre></pre></code></td></tr><tr><td>307</td><td><code><pre>        /*</pre></code></td></tr><tr><td>308</td><td><code><pre>           The length as a string.</pre></code></td></tr><tr><td>309</td><td><code><pre>        */</pre></code></td></tr><tr><td>310</td><td><code><pre></pre></code></td></tr><tr><td>311</td><td><code><pre>        strLen := &#34;&#34;</pre></code></td></tr><tr><td>312</td><td><code><pre></pre></code></td></tr><tr><td>313</td><td><code><pre>        if length &gt; 0 {</pre></code></td></tr><tr><td>314</td><td><code><pre>                strLen = &#34; - &#34; + fmt.Sprint(length)</pre></code></td></tr><tr><td>315</td><td><code><pre>        }</pre></code></td></tr><tr><td>316</td><td><code><pre></pre></code></td></tr><tr><td>317</td><td><code><pre>        /*</pre></code></td></tr><tr><td>318</td><td><code><pre>           Set the default color for the log.</pre></code></td></tr><tr><td>319</td><td><code><pre>        */</pre></code></td></tr><tr><td>320</td><td><code><pre></pre></code></td></tr><tr><td>321</td><td><code><pre>        color := 32</pre></code></td></tr><tr><td>322</td><td><code><pre></pre></code></td></tr><tr><td>323</td><td><code><pre>        /*</pre></code></td></tr><tr><td>324</td><td><code><pre>           Get the status code for the request.</pre></code></td></tr><tr><td>325</td><td><code><pre>        */</pre></code></td></tr><tr><td>326</td><td><code><pre></pre></code></td></tr><tr><td>327</td><td><code><pre>        status := res.StatusCode</pre></code></td></tr><tr><td>328</td><td><code><pre></pre></code></td></tr><tr><td>329</td><td><code><pre>        /*</pre></code></td></tr><tr><td>330</td><td><code><pre>           Pick a color for the log.</pre></code></td></tr><tr><td>331</td><td><code><pre>        */</pre></code></td></tr><tr><td>332</td><td><code><pre></pre></code></td></tr><tr><td>333</td><td><code><pre>        switch {</pre></code></td></tr><tr><td>334</td><td><code><pre>        case status &gt;= 500:</pre></code></td></tr><tr><td>335</td><td><code><pre>                color = 31</pre></code></td></tr><tr><td>336</td><td><code><pre>        case status &gt;= 400:</pre></code></td></tr><tr><td>337</td><td><code><pre>                color = 33</pre></code></td></tr><tr><td>338</td><td><code><pre>        case status &gt;= 300:</pre></code></td></tr><tr><td>339</td><td><code><pre>                color = 36</pre></code></td></tr><tr><td>340</td><td><code><pre>        }</pre></code></td></tr><tr><td>341</td><td><code><pre></pre></code></td></tr><tr><td>342</td><td><code><pre>        /*</pre></code></td></tr><tr><td>343</td><td><code><pre>           Build the log line.</pre></code></td></tr><tr><td>344</td><td><code><pre>        */</pre></code></td></tr><tr><td>345</td><td><code><pre></pre></code></td></tr><tr><td>346</td><td><code><pre>        log := &#34;\x1b[90m&#34; + loggerFormatFunctions[&#34;:method&#34;](&amp;opt, req, res)</pre></code></td></tr><tr><td>347</td><td><code><pre>        log += &#34; &#34; + loggerFormatFunctions[&#34;:url&#34;](&amp;opt, req, res) + &#34; &#34;</pre></code></td></tr><tr><td>348</td><td><code><pre>        log += &#34;\x1b[&#34; + fmt.Sprint(color) + &#34;m&#34; + fmt.Sprint(status)</pre></code></td></tr><tr><td>349</td><td><code><pre>        log += &#34; \x1b[90m&#34;</pre></code></td></tr><tr><td>350</td><td><code><pre>        log += loggerFormatFunctions[&#34;:response-time&#34;](&amp;opt, req, res)</pre></code></td></tr><tr><td>351</td><td><code><pre>        log += &#34;ms&#34; + strLen</pre></code></td></tr><tr><td>352</td><td><code><pre>        log += &#34;\x1b[0m&#34;</pre></code></td></tr><tr><td>353</td><td><code><pre></pre></code></td></tr><tr><td>354</td><td><code><pre>        /*</pre></code></td></tr><tr><td>355</td><td><code><pre>           Return the log string.</pre></code></td></tr><tr><td>356</td><td><code><pre>        */</pre></code></td></tr><tr><td>357</td><td><code><pre></pre></code></td></tr><tr><td>358</td><td><code><pre>        return log</pre></code></td></tr><tr><td>359</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_loggerFormat">func loggerFormat</div><div class="info"><a href="#s_fn_loggerFormat">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>256</td><td><code><pre>func loggerFormat(opt loggerOpt, req *Request, res *Response, format string) string {</pre></code></td></tr><tr><td>257</td><td><code><pre></pre></code></td></tr><tr><td>258</td><td><code><pre>        /*</pre></code></td></tr><tr><td>259</td><td><code><pre>           If format is &#34;dev&#34; we are done.</pre></code></td></tr><tr><td>260</td><td><code><pre>        */</pre></code></td></tr><tr><td>261</td><td><code><pre></pre></code></td></tr><tr><td>262</td><td><code><pre>        if format == &#34;dev&#34; {</pre></code></td></tr><tr><td>263</td><td><code><pre>                return loggerFormatDev(opt, req, res)</pre></code></td></tr><tr><td>264</td><td><code><pre>        }</pre></code></td></tr><tr><td>265</td><td><code><pre></pre></code></td></tr><tr><td>266</td><td><code><pre>        /*</pre></code></td></tr><tr><td>267</td><td><code><pre>           See if &#34;format&#34; is a key in loggerFormats.</pre></code></td></tr><tr><td>268</td><td><code><pre>        */</pre></code></td></tr><tr><td>269</td><td><code><pre></pre></code></td></tr><tr><td>270</td><td><code><pre>        log := loggerFormatOptions[format]</pre></code></td></tr><tr><td>271</td><td><code><pre></pre></code></td></tr><tr><td>272</td><td><code><pre>        /*</pre></code></td></tr><tr><td>273</td><td><code><pre>           If there is no format matched then use the format string as the log template.</pre></code></td></tr><tr><td>274</td><td><code><pre>        */</pre></code></td></tr><tr><td>275</td><td><code><pre></pre></code></td></tr><tr><td>276</td><td><code><pre>        if len(log) == 0 {</pre></code></td></tr><tr><td>277</td><td><code><pre>                log = format</pre></code></td></tr><tr><td>278</td><td><code><pre>        }</pre></code></td></tr><tr><td>279</td><td><code><pre></pre></code></td></tr><tr><td>280</td><td><code><pre>        /*</pre></code></td></tr><tr><td>281</td><td><code><pre>           Replace tokens in the log template string.</pre></code></td></tr><tr><td>282</td><td><code><pre>        */</pre></code></td></tr><tr><td>283</td><td><code><pre></pre></code></td></tr><tr><td>284</td><td><code><pre>        for match := range loggerFormatFunctions {</pre></code></td></tr><tr><td>285</td><td><code><pre>                log = strings.Replace(log, match, loggerFormatFunctions[match](&amp;opt, req, res), -1)</pre></code></td></tr><tr><td>286</td><td><code><pre>        }</pre></code></td></tr><tr><td>287</td><td><code><pre></pre></code></td></tr><tr><td>288</td><td><code><pre>        /*</pre></code></td></tr><tr><td>289</td><td><code><pre>           Return the final string.</pre></code></td></tr><tr><td>290</td><td><code><pre>        */</pre></code></td></tr><tr><td>291</td><td><code><pre></pre></code></td></tr><tr><td>292</td><td><code><pre>        return log</pre></code></td></tr><tr><td>293</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.Write">func Response.Write</div><div class="info"><a href="#s_fn_Response.Write">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>182</td><td><code><pre>func (this *Response) Write(data string) bool {</pre></code></td></tr><tr><td>183</td><td><code><pre></pre></code></td></tr><tr><td>184</td><td><code><pre>        /*</pre></code></td></tr><tr><td>185</td><td><code><pre>           If headers have not been sent call writeHeaders().</pre></code></td></tr><tr><td>186</td><td><code><pre>        */</pre></code></td></tr><tr><td>187</td><td><code><pre></pre></code></td></tr><tr><td>188</td><td><code><pre>        if this.HeaderSent == false {</pre></code></td></tr><tr><td>189</td><td><code><pre>                this.writeHeaders()</pre></code></td></tr><tr><td>190</td><td><code><pre>        }</pre></code></td></tr><tr><td>191</td><td><code><pre></pre></code></td></tr><tr><td>192</td><td><code><pre>        /*</pre></code></td></tr><tr><td>193</td><td><code><pre>                If the string was empty just return.</pre></code></td></tr><tr><td>194</td><td><code><pre>        */</pre></code></td></tr><tr><td>195</td><td><code><pre></pre></code></td></tr><tr><td>196</td><td><code><pre>        if len(data) == 0 {</pre></code></td></tr><tr><td>197</td><td><code><pre>                return true</pre></code></td></tr><tr><td>198</td><td><code><pre>        }</pre></code></td></tr><tr><td>199</td><td><code><pre></pre></code></td></tr><tr><td>200</td><td><code><pre>        /*</pre></code></td></tr><tr><td>201</td><td><code><pre>           Try and write the string to the client.</pre></code></td></tr><tr><td>202</td><td><code><pre>        */</pre></code></td></tr><tr><td>203</td><td><code><pre></pre></code></td></tr><tr><td>204</td><td><code><pre>        writen, err := fmt.Fprint(this.Writer, data)</pre></code></td></tr><tr><td>205</td><td><code><pre></pre></code></td></tr><tr><td>206</td><td><code><pre>        /*</pre></code></td></tr><tr><td>207</td><td><code><pre>           If there was an error return false.</pre></code></td></tr><tr><td>208</td><td><code><pre>        */</pre></code></td></tr><tr><td>209</td><td><code><pre></pre></code></td></tr><tr><td>210</td><td><code><pre>        if err != nil {</pre></code></td></tr><tr><td>211</td><td><code><pre>                return false</pre></code></td></tr><tr><td>212</td><td><code><pre>        }</pre></code></td></tr><tr><td>213</td><td><code><pre></pre></code></td></tr><tr><td>214</td><td><code><pre>        /*</pre></code></td></tr><tr><td>215</td><td><code><pre>           Return true if the number of bytes written matches the data length.</pre></code></td></tr><tr><td>216</td><td><code><pre>        */</pre></code></td></tr><tr><td>217</td><td><code><pre></pre></code></td></tr><tr><td>218</td><td><code><pre>        return writen == len(data)</pre></code></td></tr><tr><td>219</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_MethodOverride">func MethodOverride</div><div class="info"><a href="#s_fn_MethodOverride">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/method_override.go</code>:</p></div><table class="listing">
<tr><td>29</td><td><code><pre>func MethodOverride() func(*Request, *Response, func()) {</pre></code></td></tr><tr><td>30</td><td><code><pre>        return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>31</td><td><code><pre>                // If there&#39;s a Method override header.</pre></code></td></tr><tr><td>32</td><td><code><pre>                if method := req.Header.Get(&#34;X-HTTP-Method-Override&#34;); method != &#34;&#34; {</pre></code></td></tr><tr><td>33</td><td><code><pre>                        // Copy the original method into the req.Map</pre></code></td></tr><tr><td>34</td><td><code><pre>                        if _, ok := req.Map[&#34;OriginalMethod&#34;]; ok == false {</pre></code></td></tr><tr><td>35</td><td><code><pre>                                req.Map[&#34;OriginalMethod&#34;] = req.Method</pre></code></td></tr><tr><td>36</td><td><code><pre>                        }</pre></code></td></tr><tr><td>37</td><td><code><pre>                        // See if the method is supported.</pre></code></td></tr><tr><td>38</td><td><code><pre>                        if supportsMethod(method) {</pre></code></td></tr><tr><td>39</td><td><code><pre>                                // If it is then swap it in.</pre></code></td></tr><tr><td>40</td><td><code><pre>                                req.Method = strings.ToUpper(method)</pre></code></td></tr><tr><td>41</td><td><code><pre>                        }</pre></code></td></tr><tr><td>42</td><td><code><pre>                }</pre></code></td></tr><tr><td>43</td><td><code><pre>                // Call the next middleware.</pre></code></td></tr><tr><td>44</td><td><code><pre>                next()</pre></code></td></tr><tr><td>45</td><td><code><pre>        }</pre></code></td></tr><tr><td>46</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_ResponseTime">func ResponseTime</div><div class="info"><a href="#s_fn_ResponseTime">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response_time.go</code>:</p></div><table class="listing">
<tr><td>16</td><td><code><pre>func ResponseTime() func(*Request, *Response, func()) {</pre></code></td></tr><tr><td>17</td><td><code><pre>        return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>18</td><td><code><pre>                start := time.Now().UnixNano()</pre></code></td></tr><tr><td>19</td><td><code><pre>                res.On(&#34;header&#34;, func() {</pre></code></td></tr><tr><td>20</td><td><code><pre>                        duration := time.Now().UnixNano() - start</pre></code></td></tr><tr><td>21</td><td><code><pre>                        res.SetHeader(&#34;X-Response-Time&#34;, strconv.FormatInt(int64(time.Duration(duration)/time.Millisecond), 10)+&#34;ms&#34;)</pre></code></td></tr><tr><td>22</td><td><code><pre>                })</pre></code></td></tr><tr><td>23</td><td><code><pre>                next()</pre></code></td></tr><tr><td>24</td><td><code><pre>        }</pre></code></td></tr><tr><td>25</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.WriteBytes">func Response.WriteBytes</div><div class="info"><a href="#s_fn_Response.WriteBytes">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>148</td><td><code><pre>func (this *Response) WriteBytes(data []byte) bool {</pre></code></td></tr><tr><td>149</td><td><code><pre></pre></code></td></tr><tr><td>150</td><td><code><pre>        /*</pre></code></td></tr><tr><td>151</td><td><code><pre>           If headers have not been sent call writeHeaders().</pre></code></td></tr><tr><td>152</td><td><code><pre>        */</pre></code></td></tr><tr><td>153</td><td><code><pre></pre></code></td></tr><tr><td>154</td><td><code><pre>        if this.HeaderSent == false {</pre></code></td></tr><tr><td>155</td><td><code><pre>                this.writeHeaders()</pre></code></td></tr><tr><td>156</td><td><code><pre>        }</pre></code></td></tr><tr><td>157</td><td><code><pre></pre></code></td></tr><tr><td>158</td><td><code><pre>        /*</pre></code></td></tr><tr><td>159</td><td><code><pre>           Try and write the byte array to the client.</pre></code></td></tr><tr><td>160</td><td><code><pre>        */</pre></code></td></tr><tr><td>161</td><td><code><pre></pre></code></td></tr><tr><td>162</td><td><code><pre>        writen, err := this.Writer.Write(data)</pre></code></td></tr><tr><td>163</td><td><code><pre></pre></code></td></tr><tr><td>164</td><td><code><pre>        /*</pre></code></td></tr><tr><td>165</td><td><code><pre>           If there was an error return false.</pre></code></td></tr><tr><td>166</td><td><code><pre>        */</pre></code></td></tr><tr><td>167</td><td><code><pre></pre></code></td></tr><tr><td>168</td><td><code><pre>        if err != nil {</pre></code></td></tr><tr><td>169</td><td><code><pre>                return false</pre></code></td></tr><tr><td>170</td><td><code><pre>        }</pre></code></td></tr><tr><td>171</td><td><code><pre></pre></code></td></tr><tr><td>172</td><td><code><pre>        /*</pre></code></td></tr><tr><td>173</td><td><code><pre>           Return true if the number of bytes written matches the data length.</pre></code></td></tr><tr><td>174</td><td><code><pre>        */</pre></code></td></tr><tr><td>175</td><td><code><pre></pre></code></td></tr><tr><td>176</td><td><code><pre>        return writen == len(data)</pre></code></td></tr><tr><td>177</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.SetHeader">func Response.SetHeader</div><div class="info"><a href="#s_fn_Response.SetHeader">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>87</td><td><code><pre>func (this *Response) SetHeader(key string, value string) bool {</pre></code></td></tr><tr><td>88</td><td><code><pre></pre></code></td></tr><tr><td>89</td><td><code><pre>        /*</pre></code></td></tr><tr><td>90</td><td><code><pre>           If the headers have been sent nothing can be done so return false.</pre></code></td></tr><tr><td>91</td><td><code><pre>        */</pre></code></td></tr><tr><td>92</td><td><code><pre></pre></code></td></tr><tr><td>93</td><td><code><pre>        if this.HeaderSent == true {</pre></code></td></tr><tr><td>94</td><td><code><pre>                return false</pre></code></td></tr><tr><td>95</td><td><code><pre>        }</pre></code></td></tr><tr><td>96</td><td><code><pre></pre></code></td></tr><tr><td>97</td><td><code><pre>        /*</pre></code></td></tr><tr><td>98</td><td><code><pre>           http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2</pre></code></td></tr><tr><td>99</td><td><code><pre>           Message headers are case-insensitive.</pre></code></td></tr><tr><td>100</td><td><code><pre>        */</pre></code></td></tr><tr><td>101</td><td><code><pre></pre></code></td></tr><tr><td>102</td><td><code><pre>        if len(value) &gt; 0 {</pre></code></td></tr><tr><td>103</td><td><code><pre>                this.Writer.Header().Set(key, value)</pre></code></td></tr><tr><td>104</td><td><code><pre>        }</pre></code></td></tr><tr><td>105</td><td><code><pre></pre></code></td></tr><tr><td>106</td><td><code><pre>        /*</pre></code></td></tr><tr><td>107</td><td><code><pre>           The header was set so return true.</pre></code></td></tr><tr><td>108</td><td><code><pre>        */</pre></code></td></tr><tr><td>109</td><td><code><pre></pre></code></td></tr><tr><td>110</td><td><code><pre>        return true</pre></code></td></tr><tr><td>111</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_CreateServer">func CreateServer</div><div class="info"><a href="#s_fn_CreateServer">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/stackr.go</code>:</p></div><table class="listing">
<tr><td>49</td><td><code><pre>func CreateServer() *Server {</pre></code></td></tr><tr><td>50</td><td><code><pre></pre></code></td></tr><tr><td>51</td><td><code><pre>        this := &amp;Server{}</pre></code></td></tr><tr><td>52</td><td><code><pre></pre></code></td></tr><tr><td>53</td><td><code><pre>        this.Env = os.Getenv(&#34;GO_ENV&#34;)</pre></code></td></tr><tr><td>54</td><td><code><pre></pre></code></td></tr><tr><td>55</td><td><code><pre>        if this.Env == &#34;&#34; {</pre></code></td></tr><tr><td>56</td><td><code><pre>                this.Env = &#34;development&#34;</pre></code></td></tr><tr><td>57</td><td><code><pre>        }</pre></code></td></tr><tr><td>58</td><td><code><pre></pre></code></td></tr><tr><td>59</td><td><code><pre>        return this</pre></code></td></tr><tr><td>60</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_supportsMethod">func supportsMethod</div><div class="info"><a href="#s_fn_supportsMethod">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/method_override.go</code>:</p></div><table class="listing">
<tr><td>8</td><td><code><pre>func supportsMethod(method string) bool {</pre></code></td></tr><tr><td>9</td><td><code><pre>        method = strings.ToLower(method)</pre></code></td></tr><tr><td>10</td><td><code><pre>        for _, m := range httphelp.Methods {</pre></code></td></tr><tr><td>11</td><td><code><pre>                if method == m {</pre></code></td></tr><tr><td>12</td><td><code><pre>                        return true</pre></code></td></tr><tr><td>13</td><td><code><pre>                }</pre></code></td></tr><tr><td>14</td><td><code><pre>        }</pre></code></td></tr><tr><td>15</td><td><code><pre>        return false</pre></code></td></tr><tr><td>16</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.SetHeaders">func Response.SetHeaders</div><div class="info"><a href="#s_fn_Response.SetHeaders">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>73</td><td><code><pre>func (this *Response) SetHeaders(headers map[string]string) bool {</pre></code></td></tr><tr><td>74</td><td><code><pre>        for key, value := range headers {</pre></code></td></tr><tr><td>75</td><td><code><pre>                if this.SetHeader(key, value) == false {</pre></code></td></tr><tr><td>76</td><td><code><pre>                        return false</pre></code></td></tr><tr><td>77</td><td><code><pre>                }</pre></code></td></tr><tr><td>78</td><td><code><pre>        }</pre></code></td></tr><tr><td>79</td><td><code><pre>        return true</pre></code></td></tr><tr><td>80</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.End">func Response.End</div><div class="info"><a href="#s_fn_Response.End">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>224</td><td><code><pre>func (this *Response) End(data string) bool {</pre></code></td></tr><tr><td>225</td><td><code><pre></pre></code></td></tr><tr><td>226</td><td><code><pre>        status := true</pre></code></td></tr><tr><td>227</td><td><code><pre></pre></code></td></tr><tr><td>228</td><td><code><pre>        /*</pre></code></td></tr><tr><td>229</td><td><code><pre>           Write the data to the client.</pre></code></td></tr><tr><td>230</td><td><code><pre>        */</pre></code></td></tr><tr><td>231</td><td><code><pre></pre></code></td></tr><tr><td>232</td><td><code><pre>        status = this.Write(data)</pre></code></td></tr><tr><td>233</td><td><code><pre></pre></code></td></tr><tr><td>234</td><td><code><pre>        /*</pre></code></td></tr><tr><td>235</td><td><code><pre>           Set the &#34;Closed&#34; flag to true.</pre></code></td></tr><tr><td>236</td><td><code><pre>        */</pre></code></td></tr><tr><td>237</td><td><code><pre></pre></code></td></tr><tr><td>238</td><td><code><pre>        this.Closed = true</pre></code></td></tr><tr><td>239</td><td><code><pre></pre></code></td></tr><tr><td>240</td><td><code><pre>        /*</pre></code></td></tr><tr><td>241</td><td><code><pre>           Return the status of the write operation.</pre></code></td></tr><tr><td>242</td><td><code><pre>        */</pre></code></td></tr><tr><td>243</td><td><code><pre></pre></code></td></tr><tr><td>244</td><td><code><pre>        return status</pre></code></td></tr><tr><td>245</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_createRequest">func createRequest</div><div class="info"><a href="#s_fn_createRequest">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/request.go</code>:</p></div><table class="listing">
<tr><td>48</td><td><code><pre>func createRequest(raw *http.Request) *Request {</pre></code></td></tr><tr><td>49</td><td><code><pre></pre></code></td></tr><tr><td>50</td><td><code><pre>        // Create the Request type.</pre></code></td></tr><tr><td>51</td><td><code><pre>        this := &amp;Request{</pre></code></td></tr><tr><td>52</td><td><code><pre>                Request:     raw,</pre></code></td></tr><tr><td>53</td><td><code><pre>                Url:         raw.URL.RequestURI(),</pre></code></td></tr><tr><td>54</td><td><code><pre>                OriginalUrl: raw.URL.RequestURI(),</pre></code></td></tr><tr><td>55</td><td><code><pre>        }</pre></code></td></tr><tr><td>56</td><td><code><pre></pre></code></td></tr><tr><td>57</td><td><code><pre>        // A map for storing general key/values over the lifetime of the request.</pre></code></td></tr><tr><td>58</td><td><code><pre>        if this.Map == nil {</pre></code></td></tr><tr><td>59</td><td><code><pre>                this.Map = map[string]interface{}{}</pre></code></td></tr><tr><td>60</td><td><code><pre>        }</pre></code></td></tr><tr><td>61</td><td><code><pre></pre></code></td></tr><tr><td>62</td><td><code><pre>        return this</pre></code></td></tr><tr><td>63</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_@42:26">func @42:26</div><div class="info"><a href="#s_fn_@42:26">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>42</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>43</td><td><code><pre>                length := res.Writer.Header().Get(&#34;content-length&#34;)</pre></code></td></tr><tr><td>44</td><td><code><pre>                if len(length) == 0 {</pre></code></td></tr><tr><td>45</td><td><code><pre>                        length = &#34;0&#34;</pre></code></td></tr><tr><td>46</td><td><code><pre>                }</pre></code></td></tr><tr><td>47</td><td><code><pre>                return length</pre></code></td></tr><tr><td>48</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.Emit">func Response.Emit</div><div class="info"><a href="#s_fn_Response.Emit">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>61</td><td><code><pre>func (this *Response) Emit(event string) {</pre></code></td></tr><tr><td>62</td><td><code><pre>        e, ok := this.events[event]</pre></code></td></tr><tr><td>63</td><td><code><pre>        if ok {</pre></code></td></tr><tr><td>64</td><td><code><pre>                for _, fn := range e {</pre></code></td></tr><tr><td>65</td><td><code><pre>                        fn()</pre></code></td></tr><tr><td>66</td><td><code><pre>                }</pre></code></td></tr><tr><td>67</td><td><code><pre>        }</pre></code></td></tr><tr><td>68</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.writeHeaders">func Response.writeHeaders</div><div class="info"><a href="#s_fn_Response.writeHeaders">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>124</td><td><code><pre>func (this *Response) writeHeaders() {</pre></code></td></tr><tr><td>125</td><td><code><pre></pre></code></td></tr><tr><td>126</td><td><code><pre>        /*</pre></code></td></tr><tr><td>127</td><td><code><pre>           Fire an event.</pre></code></td></tr><tr><td>128</td><td><code><pre>        */</pre></code></td></tr><tr><td>129</td><td><code><pre></pre></code></td></tr><tr><td>130</td><td><code><pre>        this.Emit(&#34;header&#34;)</pre></code></td></tr><tr><td>131</td><td><code><pre></pre></code></td></tr><tr><td>132</td><td><code><pre>        /*</pre></code></td></tr><tr><td>133</td><td><code><pre>           Set the HeaderSent flag to true.</pre></code></td></tr><tr><td>134</td><td><code><pre>        */</pre></code></td></tr><tr><td>135</td><td><code><pre></pre></code></td></tr><tr><td>136</td><td><code><pre>        this.HeaderSent = true</pre></code></td></tr><tr><td>137</td><td><code><pre></pre></code></td></tr><tr><td>138</td><td><code><pre>        /*</pre></code></td></tr><tr><td>139</td><td><code><pre>           Write the headers with the current StatusCode.</pre></code></td></tr><tr><td>140</td><td><code><pre>        */</pre></code></td></tr><tr><td>141</td><td><code><pre></pre></code></td></tr><tr><td>142</td><td><code><pre>        this.Writer.WriteHeader(this.StatusCode)</pre></code></td></tr><tr><td>143</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_createResponse">func createResponse</div><div class="info"><a href="#s_fn_createResponse">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>36</td><td><code><pre>func createResponse(writer http.ResponseWriter) *Response {</pre></code></td></tr><tr><td>37</td><td><code><pre></pre></code></td></tr><tr><td>38</td><td><code><pre>        /*</pre></code></td></tr><tr><td>39</td><td><code><pre>           Create a new Response.</pre></code></td></tr><tr><td>40</td><td><code><pre>        */</pre></code></td></tr><tr><td>41</td><td><code><pre></pre></code></td></tr><tr><td>42</td><td><code><pre>        this := &amp;Response{writer, false, 200, false, nil, map[string][]func(){}}</pre></code></td></tr><tr><td>43</td><td><code><pre></pre></code></td></tr><tr><td>44</td><td><code><pre>        /*</pre></code></td></tr><tr><td>45</td><td><code><pre>           Return the finished stack.Response.</pre></code></td></tr><tr><td>46</td><td><code><pre>        */</pre></code></td></tr><tr><td>47</td><td><code><pre></pre></code></td></tr><tr><td>48</td><td><code><pre>        return this</pre></code></td></tr><tr><td>49</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.On">func Response.On</div><div class="info"><a href="#s_fn_Response.On">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>54</td><td><code><pre>func (this *Response) On(event string, fn func()) {</pre></code></td></tr><tr><td>55</td><td><code><pre>        this.events[event] = append(this.events[event], fn)</pre></code></td></tr><tr><td>56</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_@118:13">func @118:13</div><div class="info"><a href="#s_fn_@118:13">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>118</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>119</td><td><code><pre>                return fmt.Sprint(res.StatusCode)</pre></code></td></tr><tr><td>120</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_@110:17">func @110:17</div><div class="info"><a href="#s_fn_@110:17">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>110</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>111</td><td><code><pre>                return req.UserAgent()</pre></code></td></tr><tr><td>112</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_@102:15">func @102:15</div><div class="info"><a href="#s_fn_@102:15">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>102</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>103</td><td><code><pre>                return req.Referer()</pre></code></td></tr><tr><td>104</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.RemoveHeader">func Response.RemoveHeader</div><div class="info"><a href="#s_fn_Response.RemoveHeader">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/response.go</code>:</p></div><table class="listing">
<tr><td>116</td><td><code><pre>func (this *Response) RemoveHeader(key string) {</pre></code></td></tr><tr><td>117</td><td><code><pre>        this.Writer.Header().Del(key)</pre></code></td></tr><tr><td>118</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_@94:10">func @94:10</div><div class="info"><a href="#s_fn_@94:10">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>94</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>95</td><td><code><pre>                return req.OriginalUrl</pre></code></td></tr><tr><td>96</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_@86:13">func @86:13</div><div class="info"><a href="#s_fn_@86:13">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>86</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>87</td><td><code><pre>                return req.Method</pre></code></td></tr><tr><td>88</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_@78:11">func @78:11</div><div class="info"><a href="#s_fn_@78:11">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>78</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>79</td><td><code><pre>                return time.Now().Format(time.RFC1123Z)</pre></code></td></tr><tr><td>80</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_@70:18">func @70:18</div><div class="info"><a href="#s_fn_@70:18">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>70</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>71</td><td><code><pre>                return req.RemoteAddr</pre></code></td></tr><tr><td>72</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_@62:20">func @62:20</div><div class="info"><a href="#s_fn_@62:20">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>62</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>63</td><td><code><pre>                return fmt.Sprint((time.Now().UnixNano() - opt.startTime) / 1000000)</pre></code></td></tr><tr><td>64</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_@54:19">func @54:19</div><div class="info"><a href="#s_fn_@54:19">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/logger.go</code>:</p></div><table class="listing">
<tr><td>54</td><td><code><pre>func(opt *loggerOpt, req *Request, res *Response) string {</pre></code></td></tr><tr><td>55</td><td><code><pre>                return req.Proto</pre></code></td></tr><tr><td>56</td><td><code><pre>        }</pre></code></td></tr></table>

<div class="funcname" id="fn_Server.Handle">func Server.Handle</div><div class="info"><a href="#s_fn_Server.Handle">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/stackr.go</code>:</p></div><table class="listing">
<tr><td>143</td><td><code><pre>func (this *Server) Handle(req *Request, res *Response, index int) {</pre></code></td></tr><tr><td>144</td><td><code><pre></pre></code></td></tr><tr><td>145</td><td><code><pre>        /*</pre></code></td></tr><tr><td>146</td><td><code><pre>                For each call to Handle we want to catch anything that panics.</pre></code></td></tr><tr><td>147</td><td><code><pre>        */</pre></code></td></tr><tr><td>148</td><td><code><pre>        if this.Env != &#34;development&#34; {</pre></code></td></tr><tr><td>149</td><td><code><pre>                defer func() {</pre></code></td></tr><tr><td>150</td><td><code><pre>                        err := recover()</pre></code></td></tr><tr><td>151</td><td><code><pre>                        if err == nil {</pre></code></td></tr><tr><td>152</td><td><code><pre>                                return</pre></code></td></tr><tr><td>153</td><td><code><pre>                        }</pre></code></td></tr><tr><td>154</td><td><code><pre>                        res.Error = errors.New(fmt.Sprint(err))</pre></code></td></tr><tr><td>155</td><td><code><pre>                }()</pre></code></td></tr><tr><td>156</td><td><code><pre>        }</pre></code></td></tr><tr><td>157</td><td><code><pre></pre></code></td></tr><tr><td>158</td><td><code><pre>        /*</pre></code></td></tr><tr><td>159</td><td><code><pre>           If the response has been closed return.</pre></code></td></tr><tr><td>160</td><td><code><pre>        */</pre></code></td></tr><tr><td>161</td><td><code><pre></pre></code></td></tr><tr><td>162</td><td><code><pre>        if res.Closed == true {</pre></code></td></tr><tr><td>163</td><td><code><pre>                return</pre></code></td></tr><tr><td>164</td><td><code><pre>        }</pre></code></td></tr><tr><td>165</td><td><code><pre></pre></code></td></tr><tr><td>166</td><td><code><pre>        /*</pre></code></td></tr><tr><td>167</td><td><code><pre>           Create a var for the middleware.</pre></code></td></tr><tr><td>168</td><td><code><pre>        */</pre></code></td></tr><tr><td>169</td><td><code><pre></pre></code></td></tr><tr><td>170</td><td><code><pre>        var layer middleware</pre></code></td></tr><tr><td>171</td><td><code><pre></pre></code></td></tr><tr><td>172</td><td><code><pre>        /*</pre></code></td></tr><tr><td>173</td><td><code><pre>           Do we have another layer to use?</pre></code></td></tr><tr><td>174</td><td><code><pre>        */</pre></code></td></tr><tr><td>175</td><td><code><pre></pre></code></td></tr><tr><td>176</td><td><code><pre>        if index &gt;= len(this.stack) {</pre></code></td></tr><tr><td>177</td><td><code><pre>                layer = middleware{} // no</pre></code></td></tr><tr><td>178</td><td><code><pre>        } else {</pre></code></td></tr><tr><td>179</td><td><code><pre>                layer = this.stack[index] // yes</pre></code></td></tr><tr><td>180</td><td><code><pre>                index++                   // increment the index by 1</pre></code></td></tr><tr><td>181</td><td><code><pre>        }</pre></code></td></tr><tr><td>182</td><td><code><pre></pre></code></td></tr><tr><td>183</td><td><code><pre>        /*</pre></code></td></tr><tr><td>184</td><td><code><pre>           If there are no more layers and no headers have been sent return a 404.</pre></code></td></tr><tr><td>185</td><td><code><pre>        */</pre></code></td></tr><tr><td>186</td><td><code><pre></pre></code></td></tr><tr><td>187</td><td><code><pre>        if layer.Handle == nil &amp;&amp; res.HeaderSent == false {</pre></code></td></tr><tr><td>188</td><td><code><pre>                res.StatusCode = 404</pre></code></td></tr><tr><td>189</td><td><code><pre>                res.SetHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;)</pre></code></td></tr><tr><td>190</td><td><code><pre>                if req.Method == &#34;HEAD&#34; {</pre></code></td></tr><tr><td>191</td><td><code><pre>                        res.End(&#34;&#34;)</pre></code></td></tr><tr><td>192</td><td><code><pre>                        return</pre></code></td></tr><tr><td>193</td><td><code><pre>                }</pre></code></td></tr><tr><td>194</td><td><code><pre>                res.End(&#34;Cannot &#34; + fmt.Sprint(req.Method) + &#34; &#34; + fmt.Sprint(req.OriginalUrl))</pre></code></td></tr><tr><td>195</td><td><code><pre>                return</pre></code></td></tr><tr><td>196</td><td><code><pre>        }</pre></code></td></tr><tr><td>197</td><td><code><pre></pre></code></td></tr><tr><td>198</td><td><code><pre>        /*</pre></code></td></tr><tr><td>199</td><td><code><pre>           If there are no more layers and headers were sent then we are done so just return.</pre></code></td></tr><tr><td>200</td><td><code><pre>        */</pre></code></td></tr><tr><td>201</td><td><code><pre></pre></code></td></tr><tr><td>202</td><td><code><pre>        if layer.Handle == nil {</pre></code></td></tr><tr class="miss"><td>203</td><td><code><pre>                return</pre></code></td></tr><tr><td>204</td><td><code><pre>        }</pre></code></td></tr><tr><td>205</td><td><code><pre></pre></code></td></tr><tr><td>206</td><td><code><pre>        /*</pre></code></td></tr><tr><td>207</td><td><code><pre>           Otherwise call the layer Handler.</pre></code></td></tr><tr><td>208</td><td><code><pre>        */</pre></code></td></tr><tr><td>209</td><td><code><pre></pre></code></td></tr><tr><td>210</td><td><code><pre>        if strings.Contains(req.OriginalUrl, layer.Route) {</pre></code></td></tr><tr><td>211</td><td><code><pre></pre></code></td></tr><tr><td>212</td><td><code><pre>                /*</pre></code></td></tr><tr><td>213</td><td><code><pre>                   Set the value of Url to the portion after the matched layer.Route</pre></code></td></tr><tr><td>214</td><td><code><pre>                */</pre></code></td></tr><tr><td>215</td><td><code><pre></pre></code></td></tr><tr><td>216</td><td><code><pre>                req.Url = strings.TrimPrefix(req.OriginalUrl, layer.Route)</pre></code></td></tr><tr><td>217</td><td><code><pre></pre></code></td></tr><tr><td>218</td><td><code><pre>                /*</pre></code></td></tr><tr><td>219</td><td><code><pre>                   Set the matched portion of the Url.</pre></code></td></tr><tr><td>220</td><td><code><pre>                */</pre></code></td></tr><tr><td>221</td><td><code><pre></pre></code></td></tr><tr><td>222</td><td><code><pre>                req.MatchedUrl = layer.Route</pre></code></td></tr><tr><td>223</td><td><code><pre></pre></code></td></tr><tr><td>224</td><td><code><pre>                /*</pre></code></td></tr><tr><td>225</td><td><code><pre>                   Call the middleware function.</pre></code></td></tr><tr><td>226</td><td><code><pre>                */</pre></code></td></tr><tr><td>227</td><td><code><pre></pre></code></td></tr><tr><td>228</td><td><code><pre>                layer.Handle(req, res, func() {</pre></code></td></tr><tr><td>229</td><td><code><pre></pre></code></td></tr><tr><td>230</td><td><code><pre>                        /*</pre></code></td></tr><tr><td>231</td><td><code><pre>                           The value of next is a function that calls this function again, passing the index value.</pre></code></td></tr><tr><td>232</td><td><code><pre>                        */</pre></code></td></tr><tr><td>233</td><td><code><pre></pre></code></td></tr><tr><td>234</td><td><code><pre>                        this.Handle(req, res, index)</pre></code></td></tr><tr><td>235</td><td><code><pre>                })</pre></code></td></tr><tr><td>236</td><td><code><pre></pre></code></td></tr><tr><td>237</td><td><code><pre>        } else {</pre></code></td></tr><tr><td>238</td><td><code><pre></pre></code></td></tr><tr><td>239</td><td><code><pre>                /*</pre></code></td></tr><tr><td>240</td><td><code><pre>                   Call this function, passing the index value.</pre></code></td></tr><tr><td>241</td><td><code><pre>                */</pre></code></td></tr><tr><td>242</td><td><code><pre></pre></code></td></tr><tr><td>243</td><td><code><pre>                this.Handle(req, res, index)</pre></code></td></tr><tr><td>244</td><td><code><pre>        }</pre></code></td></tr><tr><td>245</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Server.Use">func Server.Use</div><div class="info"><a href="#s_fn_Server.Use">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/stackr.go</code>:</p></div><table class="listing">
<tr><td>89</td><td><code><pre>func (this *Server) Use(in ...interface{}) *Server {</pre></code></td></tr><tr><td>90</td><td><code><pre></pre></code></td></tr><tr><td>91</td><td><code><pre>        var route string</pre></code></td></tr><tr><td>92</td><td><code><pre>        var handle func(*Request, *Response, func())</pre></code></td></tr><tr><td>93</td><td><code><pre></pre></code></td></tr><tr><td>94</td><td><code><pre>        for _, i := range in {</pre></code></td></tr><tr><td>95</td><td><code><pre>                switch i.(type) {</pre></code></td></tr><tr><td>96</td><td><code><pre>                case string:</pre></code></td></tr><tr><td>97</td><td><code><pre>                        route = i.(string)</pre></code></td></tr><tr><td>98</td><td><code><pre>                case func(*Request, *Response, func()):</pre></code></td></tr><tr><td>99</td><td><code><pre>                        handle = i.(func(*Request, *Response, func()))</pre></code></td></tr><tr><td>100</td><td><code><pre>                default:</pre></code></td></tr><tr class="miss"><td>101</td><td><code><pre>                        panic(&#34;stackr: Go home handler, you&#39;re drunk!&#34;)</pre></code></td></tr><tr><td>102</td><td><code><pre>                }</pre></code></td></tr><tr><td>103</td><td><code><pre>        }</pre></code></td></tr><tr><td>104</td><td><code><pre></pre></code></td></tr><tr><td>105</td><td><code><pre>        /*</pre></code></td></tr><tr><td>106</td><td><code><pre>           If the route is empty make it &#34;/&#34;.</pre></code></td></tr><tr><td>107</td><td><code><pre>        */</pre></code></td></tr><tr><td>108</td><td><code><pre></pre></code></td></tr><tr><td>109</td><td><code><pre>        if len(route) == 0 {</pre></code></td></tr><tr><td>110</td><td><code><pre>                route = &#34;/&#34;</pre></code></td></tr><tr><td>111</td><td><code><pre>        }</pre></code></td></tr><tr><td>112</td><td><code><pre></pre></code></td></tr><tr><td>113</td><td><code><pre>        /*</pre></code></td></tr><tr><td>114</td><td><code><pre>           Strip trailing slash</pre></code></td></tr><tr><td>115</td><td><code><pre>        */</pre></code></td></tr><tr><td>116</td><td><code><pre></pre></code></td></tr><tr><td>117</td><td><code><pre>        if size := len(route); size &gt; 1 &amp;&amp; route[size-1] == &#39;/&#39; {</pre></code></td></tr><tr><td>118</td><td><code><pre>                route = route[:size-1]</pre></code></td></tr><tr><td>119</td><td><code><pre>        }</pre></code></td></tr><tr><td>120</td><td><code><pre></pre></code></td></tr><tr><td>121</td><td><code><pre>        /*</pre></code></td></tr><tr><td>122</td><td><code><pre>           Add the middleware to the stack.</pre></code></td></tr><tr><td>123</td><td><code><pre>        */</pre></code></td></tr><tr><td>124</td><td><code><pre></pre></code></td></tr><tr><td>125</td><td><code><pre>        this.stack = append(this.stack, middleware{</pre></code></td></tr><tr><td>126</td><td><code><pre>                Route:  strings.ToLower(route),</pre></code></td></tr><tr><td>127</td><td><code><pre>                Handle: handle,</pre></code></td></tr><tr><td>128</td><td><code><pre>        })</pre></code></td></tr><tr><td>129</td><td><code><pre></pre></code></td></tr><tr><td>130</td><td><code><pre>        /*</pre></code></td></tr><tr><td>131</td><td><code><pre>           Return the Server so calls can be chained.</pre></code></td></tr><tr><td>132</td><td><code><pre>        */</pre></code></td></tr><tr><td>133</td><td><code><pre></pre></code></td></tr><tr><td>134</td><td><code><pre>        return this</pre></code></td></tr><tr><td>135</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Static">func Static</div><div class="info"><a href="#s_fn_Static">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/static.go</code>:</p></div><table class="listing">
<tr><td>36</td><td><code><pre>func Static(o ...map[string]string) func(*Request, *Response, func()) {</pre></code></td></tr><tr><td>37</td><td><code><pre></pre></code></td></tr><tr><td>38</td><td><code><pre>        /*</pre></code></td></tr><tr><td>39</td><td><code><pre>           If we got options use them.</pre></code></td></tr><tr><td>40</td><td><code><pre>        */</pre></code></td></tr><tr><td>41</td><td><code><pre></pre></code></td></tr><tr><td>42</td><td><code><pre>        opt := staticOpt{}</pre></code></td></tr><tr><td>43</td><td><code><pre></pre></code></td></tr><tr><td>44</td><td><code><pre>        if len(o) == 1 {</pre></code></td></tr><tr><td>45</td><td><code><pre>                val := o[0]</pre></code></td></tr><tr><td>46</td><td><code><pre>                opt.Root = val[&#34;root&#34;]</pre></code></td></tr><tr><td>47</td><td><code><pre>                // opt.MaxAge, _ = strconv.Atoi(val[&#34;maxage&#34;])</pre></code></td></tr><tr><td>48</td><td><code><pre>                // opt.Hidden = val[&#34;hidden&#34;] == &#34;true&#34;</pre></code></td></tr><tr><td>49</td><td><code><pre>                // opt.Redirect = val[&#34;redirect&#34;] == &#34;true&#34;</pre></code></td></tr><tr><td>50</td><td><code><pre>                // opt.Index = val[&#34;index&#34;] == &#34;true&#34;</pre></code></td></tr><tr><td>51</td><td><code><pre>        }</pre></code></td></tr><tr><td>52</td><td><code><pre></pre></code></td></tr><tr><td>53</td><td><code><pre>        /*</pre></code></td></tr><tr><td>54</td><td><code><pre>           File Stat Cache.</pre></code></td></tr><tr><td>55</td><td><code><pre>        */</pre></code></td></tr><tr><td>56</td><td><code><pre></pre></code></td></tr><tr><td>57</td><td><code><pre>        statCache := make(map[string]int)</pre></code></td></tr><tr><td>58</td><td><code><pre></pre></code></td></tr><tr><td>59</td><td><code><pre>        /*</pre></code></td></tr><tr><td>60</td><td><code><pre>           The default loction of static files.</pre></code></td></tr><tr><td>61</td><td><code><pre>        */</pre></code></td></tr><tr><td>62</td><td><code><pre></pre></code></td></tr><tr><td>63</td><td><code><pre>        root := &#34;./public/&#34;</pre></code></td></tr><tr><td>64</td><td><code><pre></pre></code></td></tr><tr><td>65</td><td><code><pre>        /*</pre></code></td></tr><tr><td>66</td><td><code><pre>           If we were given a root use it.</pre></code></td></tr><tr><td>67</td><td><code><pre>        */</pre></code></td></tr><tr><td>68</td><td><code><pre></pre></code></td></tr><tr><td>69</td><td><code><pre>        if len(opt.Root) &gt; 0 {</pre></code></td></tr><tr><td>70</td><td><code><pre></pre></code></td></tr><tr><td>71</td><td><code><pre>                root = opt.Root</pre></code></td></tr><tr><td>72</td><td><code><pre></pre></code></td></tr><tr><td>73</td><td><code><pre>                /*</pre></code></td></tr><tr><td>74</td><td><code><pre>                   Add trailing slash if one is not there.</pre></code></td></tr><tr><td>75</td><td><code><pre>                */</pre></code></td></tr><tr><td>76</td><td><code><pre></pre></code></td></tr><tr><td>77</td><td><code><pre>                if size := len(root); size &gt; 1 &amp;&amp; root[size-1] != &#39;/&#39; {</pre></code></td></tr><tr><td>78</td><td><code><pre>                        root += &#34;/&#34;</pre></code></td></tr><tr><td>79</td><td><code><pre>                }</pre></code></td></tr><tr><td>80</td><td><code><pre>        }</pre></code></td></tr><tr><td>81</td><td><code><pre></pre></code></td></tr><tr><td>82</td><td><code><pre>        /*</pre></code></td></tr><tr><td>83</td><td><code><pre>           Create a http.FileServer to server the files.</pre></code></td></tr><tr><td>84</td><td><code><pre>        */</pre></code></td></tr><tr><td>85</td><td><code><pre></pre></code></td></tr><tr><td>86</td><td><code><pre>        fileServer := http.FileServer(http.Dir(root))</pre></code></td></tr><tr><td>87</td><td><code><pre></pre></code></td></tr><tr><td>88</td><td><code><pre>        /*</pre></code></td></tr><tr><td>89</td><td><code><pre>           Return the Handle function.</pre></code></td></tr><tr><td>90</td><td><code><pre>        */</pre></code></td></tr><tr><td>91</td><td><code><pre></pre></code></td></tr><tr><td>92</td><td><code><pre>        return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>93</td><td><code><pre></pre></code></td></tr><tr><td>94</td><td><code><pre>                /*</pre></code></td></tr><tr><td>95</td><td><code><pre>                   Because http.FileServer serves directories and it&#39;s own 404 we</pre></code></td></tr><tr><td>96</td><td><code><pre>                   want to see if the file is really there before we hand of to it.</pre></code></td></tr><tr><td>97</td><td><code><pre>                   To do that we see if the file exists. If it doesn&#39;t, then we return quickly.</pre></code></td></tr><tr><td>98</td><td><code><pre></pre></code></td></tr><tr><td>99</td><td><code><pre>                   Question: Is this not really expensive?</pre></code></td></tr><tr><td>100</td><td><code><pre>                   Answer: It&#39;s not ideal. Writing a custom static server is on the todo list.</pre></code></td></tr><tr><td>101</td><td><code><pre>                */</pre></code></td></tr><tr><td>102</td><td><code><pre></pre></code></td></tr><tr><td>103</td><td><code><pre>                filepath := root + req.Url</pre></code></td></tr><tr><td>104</td><td><code><pre></pre></code></td></tr><tr><td>105</td><td><code><pre>                /*</pre></code></td></tr><tr><td>106</td><td><code><pre>                   Check the stat cache as it&#39;s quicker than doing a stat on a file.</pre></code></td></tr><tr><td>107</td><td><code><pre>                */</pre></code></td></tr><tr><td>108</td><td><code><pre></pre></code></td></tr><tr><td>109</td><td><code><pre>                if statCache[filepath] == -1 {</pre></code></td></tr><tr class="miss"><td>110</td><td><code><pre>                        next()</pre></code></td></tr><tr class="miss"><td>111</td><td><code><pre>                        return</pre></code></td></tr><tr><td>112</td><td><code><pre>                }</pre></code></td></tr><tr><td>113</td><td><code><pre></pre></code></td></tr><tr><td>114</td><td><code><pre>                /*</pre></code></td></tr><tr><td>115</td><td><code><pre>                   If the value of stat cache is 0 it means this is the first request for the filename.</pre></code></td></tr><tr><td>116</td><td><code><pre>                */</pre></code></td></tr><tr><td>117</td><td><code><pre></pre></code></td></tr><tr><td>118</td><td><code><pre>                if statCache[filepath] == 0 {</pre></code></td></tr><tr><td>119</td><td><code><pre></pre></code></td></tr><tr><td>120</td><td><code><pre>                        /*</pre></code></td></tr><tr><td>121</td><td><code><pre>                           Stat the filename.</pre></code></td></tr><tr><td>122</td><td><code><pre>                        */</pre></code></td></tr><tr><td>123</td><td><code><pre></pre></code></td></tr><tr><td>124</td><td><code><pre>                        if stat, err := os.Stat(filepath); err != nil || stat.IsDir() == true {</pre></code></td></tr><tr><td>125</td><td><code><pre></pre></code></td></tr><tr><td>126</td><td><code><pre>                                /*</pre></code></td></tr><tr><td>127</td><td><code><pre>                                   If there is no file set stat cache to -1 and return.</pre></code></td></tr><tr><td>128</td><td><code><pre>                                */</pre></code></td></tr><tr><td>129</td><td><code><pre></pre></code></td></tr><tr><td>130</td><td><code><pre>                                statCache[filepath] = -1</pre></code></td></tr><tr><td>131</td><td><code><pre></pre></code></td></tr><tr><td>132</td><td><code><pre>                                next()</pre></code></td></tr><tr><td>133</td><td><code><pre>                                return</pre></code></td></tr><tr><td>134</td><td><code><pre>                        }</pre></code></td></tr><tr><td>135</td><td><code><pre></pre></code></td></tr><tr><td>136</td><td><code><pre>                        /*</pre></code></td></tr><tr><td>137</td><td><code><pre>                           If there was a file set stat cache to 1 and let the FileServer serve it.</pre></code></td></tr><tr><td>138</td><td><code><pre>                        */</pre></code></td></tr><tr><td>139</td><td><code><pre></pre></code></td></tr><tr><td>140</td><td><code><pre>                        statCache[filepath] = 1</pre></code></td></tr><tr><td>141</td><td><code><pre>                }</pre></code></td></tr><tr><td>142</td><td><code><pre></pre></code></td></tr><tr><td>143</td><td><code><pre>                /*</pre></code></td></tr><tr><td>144</td><td><code><pre>                   If we have to serve a file strip the matched Url and call ServeHTTP() on the fileServer.</pre></code></td></tr><tr><td>145</td><td><code><pre>                */</pre></code></td></tr><tr><td>146</td><td><code><pre></pre></code></td></tr><tr><td>147</td><td><code><pre>                http.StripPrefix(req.MatchedUrl, fileServer).ServeHTTP(res.Writer, req.Request)</pre></code></td></tr><tr><td>148</td><td><code><pre></pre></code></td></tr><tr><td>149</td><td><code><pre>                /*</pre></code></td></tr><tr><td>150</td><td><code><pre>                        As the above line sets headers we have to manually set the flag to true.</pre></code></td></tr><tr><td>151</td><td><code><pre>                */</pre></code></td></tr><tr><td>152</td><td><code><pre></pre></code></td></tr><tr><td>153</td><td><code><pre>                res.HeaderSent = true</pre></code></td></tr><tr><td>154</td><td><code><pre></pre></code></td></tr><tr><td>155</td><td><code><pre>                /*</pre></code></td></tr><tr><td>156</td><td><code><pre>                   Now call End() to make sure we don&#39;t process any more middleware.</pre></code></td></tr><tr><td>157</td><td><code><pre>                */</pre></code></td></tr><tr><td>158</td><td><code><pre></pre></code></td></tr><tr><td>159</td><td><code><pre>                res.End(&#34;&#34;)</pre></code></td></tr><tr><td>160</td><td><code><pre>        }</pre></code></td></tr><tr><td>161</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Server.Listen">func Server.Listen</div><div class="info"><a href="#s_fn_Server.Listen">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/stackr.go</code>:</p></div><table class="listing">
<tr><td>263</td><td><code><pre>func (this *Server) Listen(port int) {</pre></code></td></tr><tr><td>264</td><td><code><pre></pre></code></td></tr><tr><td>265</td><td><code><pre>        /*</pre></code></td></tr><tr><td>266</td><td><code><pre>           Set the address to run on.</pre></code></td></tr><tr><td>267</td><td><code><pre>        */</pre></code></td></tr><tr><td>268</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>269</td><td><code><pre>        address := &#34;:&#34; + fmt.Sprint(port)</pre></code></td></tr><tr><td>270</td><td><code><pre></pre></code></td></tr><tr><td>271</td><td><code><pre>        /*</pre></code></td></tr><tr><td>272</td><td><code><pre>           Start the server by mapping all URLs into this Server.</pre></code></td></tr><tr><td>273</td><td><code><pre>        */</pre></code></td></tr><tr><td>274</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>275</td><td><code><pre>        log.Fatal(http.ListenAndServe(address, this))</pre></code></td></tr><tr><td>276</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Server.ListenTLS">func Server.ListenTLS</div><div class="info"><a href="#s_fn_Server.ListenTLS">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/stackr.go</code>:</p></div><table class="listing">
<tr><td>281</td><td><code><pre>func (this *Server) ListenTLS(port int, certFile string, keyFile string) {</pre></code></td></tr><tr><td>282</td><td><code><pre></pre></code></td></tr><tr><td>283</td><td><code><pre>        /*</pre></code></td></tr><tr><td>284</td><td><code><pre>           Set the address to run on.</pre></code></td></tr><tr><td>285</td><td><code><pre>        */</pre></code></td></tr><tr><td>286</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>287</td><td><code><pre>        address := &#34;:&#34; + fmt.Sprint(port)</pre></code></td></tr><tr><td>288</td><td><code><pre></pre></code></td></tr><tr><td>289</td><td><code><pre>        /*</pre></code></td></tr><tr><td>290</td><td><code><pre>           Start the server by mapping all URLs into this Server.</pre></code></td></tr><tr><td>291</td><td><code><pre>        */</pre></code></td></tr><tr><td>292</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>293</td><td><code><pre>        log.Fatal(http.ListenAndServeTLS(address, certFile, keyFile, this))</pre></code></td></tr><tr><td>294</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Server.ServeHTTP">func Server.ServeHTTP</div><div class="info"><a href="#s_fn_Server.ServeHTTP">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stackr/stackr.go</code>:</p></div><table class="listing">
<tr><td>250</td><td><code><pre>func (this *Server) ServeHTTP(res http.ResponseWriter, req *http.Request) {</pre></code></td></tr><tr><td>251</td><td><code><pre></pre></code></td></tr><tr><td>252</td><td><code><pre>        /*</pre></code></td></tr><tr><td>253</td><td><code><pre>           Pass the res and req into there repective create functions.</pre></code></td></tr><tr><td>254</td><td><code><pre>           The results of these are then passed to stack.server.Handle().</pre></code></td></tr><tr><td>255</td><td><code><pre>        */</pre></code></td></tr><tr><td>256</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>257</td><td><code><pre>        this.Handle(createRequest(req), createResponse(res), 0)</pre></code></td></tr><tr><td>258</td><td><code><pre>}</pre></code></td></tr></table>
<script type="text/javascript">
document.getElementById("totalcov").textContent = "96.44%"
</script>
<!-- Can be parsed by external script
PACKAGE:github.com/ricallinson/stackr DONE:96.44
-->

    </body>
</html>
