
<html>
    <head>
        <title>Coverage Report</title>
        
        <style type="text/css">
            body { background-color: #fff; }
            table {
                margin-left: 10px;
                border-collapse: collapse;
            }
            td { 
                background-color: #fff; 
                padding: 2px;
            }
            table.overview td {
                padding-right: 20px;
            }
            td.percent, td.linecount { text-align: right; }
            div.package, #totalcov { 
                position: fixed;
                color: #fff;
                background-color: #375eab; 
                font-size: 16px;
                font-weight: bold;
                padding: 10px;
                border-radius: 5px 5px 5px 5px;
            }
            div.package, #totalcov { 
                float: right; 
                right: 10px;
            }
            #totalcov { 
                background-color: #fff;
                color: #000;
                border: 1px solid #375eab;
                clear: both;
            }
            div.package {
                top: 10px;
            }
            #doctitle { 
                background-color: #fff; 
                font-size: 24px;
                margin-top: 20px;
                margin-left: 10px;
                color: #375eab;
                font-weight: bold;
            }
            #about {
                margin-left: 18px;
                font-size: 10px;
            }
            table tr:last-child td {
                font-weight: bold;
            }
            .functitle, .funcname { 
                text-align: center; 
                font-size: 20px; 
                font-weight: bold; 
                color: 375eab; 
            }
            .funcname {
                text-align: left;
                margin-top: 20px;
                margin-left: 10px;
                margin-bottom: 20px;
                padding: 2px 5px 5px;
                background-color: #e0ebf5;
            }
            table.listing {
                margin-left: 10px;
            }
            table.listing td {
                padding: 0px;
                font-size: 12px;
                background-color: #eee; 
                vertical-align: top;
                padding-left: 10px;
                border-bottom: 1px solid #fff;
            }
            table.listing td:first-child {
                text-align: right;
                font-weight: bold;
                vertical-align: center;
            }
            table.listing tr.miss td {
                background-color: #FFBBB8;
            }
            table.listing tr:last-child td {
                font-weight: normal;
                color: #000;
            }
            table.listing tr:last-child td:first-child {
                font-weight: bold;
            }
            .info {
                margin-left: 10px;
            }
            .info code {
            }
            pre { margin: 1px; }
            pre.cmd { 
                background-color: #e9e9e9;
                border-radius: 5px 5px 5px 5px;
                padding: 10px;
                margin: 20px;
                line-height: 18px;
                font-size; 14px;
            }
            a { 
                text-decoration: none; 
                color: #375eab;
            }
            a:hover { text-decoration: underline; }
            p { margin-left: 10px; }
        </style>
        
    </head>
    <body>
        <div id="doctitle">Coverage Report</div>
    <div id="about">Generated on 24 Aug 13 15:10 +0800 with <a href="https://github.com/matm/gocov-html">gocov-html</a></div><div class="package">github.com/ricallinson/stack</div>
<div id="totalcov">github.com/ricallinson/stack</div>
<div class="funcname">Overview</div><p>This is a coverage report created after analysis of the <code>github.com/ricallinson/stack</code> package. It 
        has been generated with the following command:</p><pre class="cmd">gocov test github.com/ricallinson/stack | gocov-html</pre>        <p>Here are the stats. Please select a function name to view its implementation and see what's left for testing.</p><table class="overview">
<tr id="s_fn_Server.handle"><td><code><a href="#fn_Server.handle">Server.handle(...)</a></code></td><td><code>github.com/ricallinson/stack/connect.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>23/23</code></td></tr>
<tr id="s_fn_Response.WriteBytes"><td><code><a href="#fn_Response.WriteBytes">Response.WriteBytes(...)</a></code></td><td><code>github.com/ricallinson/stack/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>6/6</code></td></tr>
<tr id="s_fn_Server.Use"><td><code><a href="#fn_Server.Use">Server.Use(...)</a></code></td><td><code>github.com/ricallinson/stack/connect.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>6/6</code></td></tr>
<tr id="s_fn_Response.Write"><td><code><a href="#fn_Response.Write">Response.Write(...)</a></code></td><td><code>github.com/ricallinson/stack/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>6/6</code></td></tr>
<tr id="s_fn_CreateRequest"><td><code><a href="#fn_CreateRequest">CreateRequest(...)</a></code></td><td><code>github.com/ricallinson/stack/request.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>5/5</code></td></tr>
<tr id="s_fn_Response.SetHeaders"><td><code><a href="#fn_Response.SetHeaders">Response.SetHeaders(...)</a></code></td><td><code>github.com/ricallinson/stack/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>4/4</code></td></tr>
<tr id="s_fn_Response.SetHeader"><td><code><a href="#fn_Response.SetHeader">Response.SetHeader(...)</a></code></td><td><code>github.com/ricallinson/stack/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>4/4</code></td></tr>
<tr id="s_fn_CreateResponse"><td><code><a href="#fn_CreateResponse">CreateResponse(...)</a></code></td><td><code>github.com/ricallinson/stack/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>4/4</code></td></tr>
<tr id="s_fn_Response.End"><td><code><a href="#fn_Response.End">Response.End(...)</a></code></td><td><code>github.com/ricallinson/stack/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>3/3</code></td></tr>
<tr id="s_fn_Response.writeHeaders"><td><code><a href="#fn_Response.writeHeaders">Response.writeHeaders(...)</a></code></td><td><code>github.com/ricallinson/stack/response.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>2/2</code></td></tr>
<tr id="s_fn_CreateServer"><td><code><a href="#fn_CreateServer">CreateServer(...)</a></code></td><td><code>github.com/ricallinson/stack/connect.go</code></td><td class="percent"><code>100.00%</code></td><td class="linecount"><code>1/1</code></td></tr>
<tr id="s_fn_Favicon"><td><code><a href="#fn_Favicon">Favicon(...)</a></code></td><td><code>github.com/ricallinson/stack/favicon.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/29</code></td></tr>
<tr id="s_fn_loggerFormatDev"><td><code><a href="#fn_loggerFormatDev">loggerFormatDev(...)</a></code></td><td><code>github.com/ricallinson/stack/logger.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/19</code></td></tr>
<tr id="s_fn_Static"><td><code><a href="#fn_Static">Static(...)</a></code></td><td><code>github.com/ricallinson/stack/static.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/9</code></td></tr>
<tr id="s_fn_Logger"><td><code><a href="#fn_Logger">Logger(...)</a></code></td><td><code>github.com/ricallinson/stack/logger.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/7</code></td></tr>
<tr id="s_fn_Server.ListenTLS"><td><code><a href="#fn_Server.ListenTLS">Server.ListenTLS(...)</a></code></td><td><code>github.com/ricallinson/stack/connect.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/2</code></td></tr>
<tr id="s_fn_Server.Listen"><td><code><a href="#fn_Server.Listen">Server.Listen(...)</a></code></td><td><code>github.com/ricallinson/stack/connect.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/2</code></td></tr>
<tr id="s_fn_Handler.ServeHTTP"><td><code><a href="#fn_Handler.ServeHTTP">Handler.ServeHTTP(...)</a></code></td><td><code>github.com/ricallinson/stack/http.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/1</code></td></tr>
<tr id="s_fn_createHttpHandler"><td><code><a href="#fn_createHttpHandler">createHttpHandler(...)</a></code></td><td><code>github.com/ricallinson/stack/http.go</code></td><td class="percent"><code>0.00%</code></td><td class="linecount"><code>0/1</code></td></tr>
<tr><td colspan="2"><code>github.com/ricallinson/stack</code></td><td class="percent"><code>47.76%</code></td><td class="linecount"><code>64/134</code></td></tr>
</table>

<div class="funcname" id="fn_Server.handle">func Server.handle</div><div class="info"><a href="#s_fn_Server.handle">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/connect.go</code>:</p></div><table class="listing">
<tr><td>95</td><td><code><pre>func (this *Server) handle(req *Request, res *Response, index int) {</pre></code></td></tr><tr><td>96</td><td><code><pre></pre></code></td></tr><tr><td>97</td><td><code><pre>    var layer middleware</pre></code></td></tr><tr><td>98</td><td><code><pre></pre></code></td></tr><tr><td>99</td><td><code><pre>    /*</pre></code></td></tr><tr><td>100</td><td><code><pre>        If the response has been closed return.</pre></code></td></tr><tr><td>101</td><td><code><pre>    */</pre></code></td></tr><tr><td>102</td><td><code><pre></pre></code></td></tr><tr><td>103</td><td><code><pre>    if res.Closed == true {</pre></code></td></tr><tr><td>104</td><td><code><pre>        return</pre></code></td></tr><tr><td>105</td><td><code><pre>    }</pre></code></td></tr><tr><td>106</td><td><code><pre></pre></code></td></tr><tr><td>107</td><td><code><pre>    /*</pre></code></td></tr><tr><td>108</td><td><code><pre>        Do we have another layer to use?</pre></code></td></tr><tr><td>109</td><td><code><pre>    */</pre></code></td></tr><tr><td>110</td><td><code><pre></pre></code></td></tr><tr><td>111</td><td><code><pre>    if index &gt;= len(this.stack) {</pre></code></td></tr><tr><td>112</td><td><code><pre>        layer = middleware{}</pre></code></td></tr><tr><td>113</td><td><code><pre>    } else {</pre></code></td></tr><tr><td>114</td><td><code><pre>        layer = this.stack[index];</pre></code></td></tr><tr><td>115</td><td><code><pre>        index++</pre></code></td></tr><tr><td>116</td><td><code><pre>    }</pre></code></td></tr><tr><td>117</td><td><code><pre></pre></code></td></tr><tr><td>118</td><td><code><pre>    /*</pre></code></td></tr><tr><td>119</td><td><code><pre>        If there are no more layers and no headers have been sent return a 404.</pre></code></td></tr><tr><td>120</td><td><code><pre>    */</pre></code></td></tr><tr><td>121</td><td><code><pre></pre></code></td></tr><tr><td>122</td><td><code><pre>    if layer.Handle == nil &amp;&amp; res.HeaderSent == false {</pre></code></td></tr><tr><td>123</td><td><code><pre>        res.StatusCode = 404</pre></code></td></tr><tr><td>124</td><td><code><pre>        res.SetHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;)</pre></code></td></tr><tr><td>125</td><td><code><pre>        if req.Raw.Method == &#34;HEAD&#34; {</pre></code></td></tr><tr><td>126</td><td><code><pre>            res.End(&#34;&#34;)</pre></code></td></tr><tr><td>127</td><td><code><pre>            return</pre></code></td></tr><tr><td>128</td><td><code><pre>        }</pre></code></td></tr><tr><td>129</td><td><code><pre>        res.End(&#34;Cannot &#34; + fmt.Sprint(req.Raw.Method) + &#34; &#34; + fmt.Sprint(req.OriginalUrl));</pre></code></td></tr><tr><td>130</td><td><code><pre>        return</pre></code></td></tr><tr><td>131</td><td><code><pre>    }</pre></code></td></tr><tr><td>132</td><td><code><pre></pre></code></td></tr><tr><td>133</td><td><code><pre>    /*</pre></code></td></tr><tr><td>134</td><td><code><pre>        If there are no more layers and headers were sent then we are done.</pre></code></td></tr><tr><td>135</td><td><code><pre>    */</pre></code></td></tr><tr><td>136</td><td><code><pre></pre></code></td></tr><tr><td>137</td><td><code><pre>    if layer.Handle == nil {</pre></code></td></tr><tr><td>138</td><td><code><pre>        return</pre></code></td></tr><tr><td>139</td><td><code><pre>    }</pre></code></td></tr><tr><td>140</td><td><code><pre></pre></code></td></tr><tr><td>141</td><td><code><pre>    /*</pre></code></td></tr><tr><td>142</td><td><code><pre>        Otherwise call the layer handler.</pre></code></td></tr><tr><td>143</td><td><code><pre>    */</pre></code></td></tr><tr><td>144</td><td><code><pre></pre></code></td></tr><tr><td>145</td><td><code><pre>    if strings.Contains(strings.ToLower(req.OriginalUrl), layer.Route) {</pre></code></td></tr><tr><td>146</td><td><code><pre></pre></code></td></tr><tr><td>147</td><td><code><pre>        /*</pre></code></td></tr><tr><td>148</td><td><code><pre>            Set the value of Url to the portion after the matched layer.Route</pre></code></td></tr><tr><td>149</td><td><code><pre>        */</pre></code></td></tr><tr><td>150</td><td><code><pre></pre></code></td></tr><tr><td>151</td><td><code><pre>        req.Url = strings.TrimPrefix(req.OriginalUrl, layer.Route)</pre></code></td></tr><tr><td>152</td><td><code><pre>        </pre></code></td></tr><tr><td>153</td><td><code><pre>        /*</pre></code></td></tr><tr><td>154</td><td><code><pre>            Set the matched portion of the Url.</pre></code></td></tr><tr><td>155</td><td><code><pre>        */</pre></code></td></tr><tr><td>156</td><td><code><pre></pre></code></td></tr><tr><td>157</td><td><code><pre>        req.MatchedUrl = layer.Route</pre></code></td></tr><tr><td>158</td><td><code><pre></pre></code></td></tr><tr><td>159</td><td><code><pre>        /*</pre></code></td></tr><tr><td>160</td><td><code><pre>            Call the middleware function.</pre></code></td></tr><tr><td>161</td><td><code><pre>        */</pre></code></td></tr><tr><td>162</td><td><code><pre></pre></code></td></tr><tr><td>163</td><td><code><pre>        layer.Handle(req, res, func() {</pre></code></td></tr><tr><td>164</td><td><code><pre></pre></code></td></tr><tr><td>165</td><td><code><pre>            /*</pre></code></td></tr><tr><td>166</td><td><code><pre>                The value of next is a function that calls this function again, passing the index value.</pre></code></td></tr><tr><td>167</td><td><code><pre>            */</pre></code></td></tr><tr><td>168</td><td><code><pre></pre></code></td></tr><tr><td>169</td><td><code><pre>            this.handle(req, res, index)</pre></code></td></tr><tr><td>170</td><td><code><pre>        })</pre></code></td></tr><tr><td>171</td><td><code><pre>    }</pre></code></td></tr><tr><td>172</td><td><code><pre></pre></code></td></tr><tr><td>173</td><td><code><pre>    /*</pre></code></td></tr><tr><td>174</td><td><code><pre>        Call this function again, passing the index value.</pre></code></td></tr><tr><td>175</td><td><code><pre>    */</pre></code></td></tr><tr><td>176</td><td><code><pre></pre></code></td></tr><tr><td>177</td><td><code><pre>    this.handle(req, res, index)</pre></code></td></tr><tr><td>178</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.WriteBytes">func Response.WriteBytes</div><div class="info"><a href="#s_fn_Response.WriteBytes">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/response.go</code>:</p></div><table class="listing">
<tr><td>117</td><td><code><pre>func (this *Response) WriteBytes(data []byte) (bool) {</pre></code></td></tr><tr><td>118</td><td><code><pre></pre></code></td></tr><tr><td>119</td><td><code><pre>    /*</pre></code></td></tr><tr><td>120</td><td><code><pre>        If headers have not been sent call writeHeaders().</pre></code></td></tr><tr><td>121</td><td><code><pre>    */</pre></code></td></tr><tr><td>122</td><td><code><pre></pre></code></td></tr><tr><td>123</td><td><code><pre>    if this.HeaderSent == false {</pre></code></td></tr><tr><td>124</td><td><code><pre>        this.writeHeaders()</pre></code></td></tr><tr><td>125</td><td><code><pre>    }</pre></code></td></tr><tr><td>126</td><td><code><pre></pre></code></td></tr><tr><td>127</td><td><code><pre>    /*</pre></code></td></tr><tr><td>128</td><td><code><pre>        Try and write the byte array to the client.</pre></code></td></tr><tr><td>129</td><td><code><pre>    */</pre></code></td></tr><tr><td>130</td><td><code><pre></pre></code></td></tr><tr><td>131</td><td><code><pre>    writen, err := this.Writer.Write(data)</pre></code></td></tr><tr><td>132</td><td><code><pre></pre></code></td></tr><tr><td>133</td><td><code><pre>    /*</pre></code></td></tr><tr><td>134</td><td><code><pre>        If there was an error return false.</pre></code></td></tr><tr><td>135</td><td><code><pre>    */</pre></code></td></tr><tr><td>136</td><td><code><pre></pre></code></td></tr><tr><td>137</td><td><code><pre>    if err != nil {</pre></code></td></tr><tr><td>138</td><td><code><pre>        return false</pre></code></td></tr><tr><td>139</td><td><code><pre>    }</pre></code></td></tr><tr><td>140</td><td><code><pre></pre></code></td></tr><tr><td>141</td><td><code><pre>    /*</pre></code></td></tr><tr><td>142</td><td><code><pre>        Return true if the number of bytes written matches the data length.</pre></code></td></tr><tr><td>143</td><td><code><pre>    */</pre></code></td></tr><tr><td>144</td><td><code><pre></pre></code></td></tr><tr><td>145</td><td><code><pre>    return writen == len(data)</pre></code></td></tr><tr><td>146</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Server.Use">func Server.Use</div><div class="info"><a href="#s_fn_Server.Use">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/connect.go</code>:</p></div><table class="listing">
<tr><td>54</td><td><code><pre>func (this *Server) Use(route string, handle func(*Request, *Response, func())) (*Server) {</pre></code></td></tr><tr><td>55</td><td><code><pre></pre></code></td></tr><tr><td>56</td><td><code><pre>    /*</pre></code></td></tr><tr><td>57</td><td><code><pre>        If the route is empty make it &#34;/&#34;.</pre></code></td></tr><tr><td>58</td><td><code><pre>    */</pre></code></td></tr><tr><td>59</td><td><code><pre></pre></code></td></tr><tr><td>60</td><td><code><pre>    if len(route) == 0 {</pre></code></td></tr><tr><td>61</td><td><code><pre>        route = &#34;/&#34;</pre></code></td></tr><tr><td>62</td><td><code><pre>    }</pre></code></td></tr><tr><td>63</td><td><code><pre></pre></code></td></tr><tr><td>64</td><td><code><pre>    /*</pre></code></td></tr><tr><td>65</td><td><code><pre>        Strip trailing slash</pre></code></td></tr><tr><td>66</td><td><code><pre>    */</pre></code></td></tr><tr><td>67</td><td><code><pre></pre></code></td></tr><tr><td>68</td><td><code><pre>    if size := len(route); size &gt; 1 &amp;&amp; route[size-1] == &#39;/&#39; {</pre></code></td></tr><tr><td>69</td><td><code><pre>        route = route[:size-1]</pre></code></td></tr><tr><td>70</td><td><code><pre>    }</pre></code></td></tr><tr><td>71</td><td><code><pre></pre></code></td></tr><tr><td>72</td><td><code><pre>    /*</pre></code></td></tr><tr><td>73</td><td><code><pre>        Add the middleware to the stack.</pre></code></td></tr><tr><td>74</td><td><code><pre>    */</pre></code></td></tr><tr><td>75</td><td><code><pre></pre></code></td></tr><tr><td>76</td><td><code><pre>    this.stack = append(this.stack, middleware{</pre></code></td></tr><tr><td>77</td><td><code><pre>        Route: strings.ToLower(route),</pre></code></td></tr><tr><td>78</td><td><code><pre>        Handle: handle,</pre></code></td></tr><tr><td>79</td><td><code><pre>    })</pre></code></td></tr><tr><td>80</td><td><code><pre></pre></code></td></tr><tr><td>81</td><td><code><pre>    /*</pre></code></td></tr><tr><td>82</td><td><code><pre>        Return the Server so calls can be chained.</pre></code></td></tr><tr><td>83</td><td><code><pre>    */</pre></code></td></tr><tr><td>84</td><td><code><pre></pre></code></td></tr><tr><td>85</td><td><code><pre>    return this</pre></code></td></tr><tr><td>86</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.Write">func Response.Write</div><div class="info"><a href="#s_fn_Response.Write">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/response.go</code>:</p></div><table class="listing">
<tr><td>152</td><td><code><pre>func (this *Response) Write(data string) (bool) {</pre></code></td></tr><tr><td>153</td><td><code><pre></pre></code></td></tr><tr><td>154</td><td><code><pre>    /*</pre></code></td></tr><tr><td>155</td><td><code><pre>        If headers have not been sent call writeHeaders().</pre></code></td></tr><tr><td>156</td><td><code><pre>    */</pre></code></td></tr><tr><td>157</td><td><code><pre></pre></code></td></tr><tr><td>158</td><td><code><pre>    if this.HeaderSent == false {</pre></code></td></tr><tr><td>159</td><td><code><pre>        this.writeHeaders()</pre></code></td></tr><tr><td>160</td><td><code><pre>    }</pre></code></td></tr><tr><td>161</td><td><code><pre></pre></code></td></tr><tr><td>162</td><td><code><pre>    /*</pre></code></td></tr><tr><td>163</td><td><code><pre>        Try and write the string to the client.</pre></code></td></tr><tr><td>164</td><td><code><pre>    */</pre></code></td></tr><tr><td>165</td><td><code><pre></pre></code></td></tr><tr><td>166</td><td><code><pre>    writen, err := fmt.Fprint(this.Writer, data)</pre></code></td></tr><tr><td>167</td><td><code><pre></pre></code></td></tr><tr><td>168</td><td><code><pre>    /*</pre></code></td></tr><tr><td>169</td><td><code><pre>        If there was an error return false.</pre></code></td></tr><tr><td>170</td><td><code><pre>    */</pre></code></td></tr><tr><td>171</td><td><code><pre></pre></code></td></tr><tr><td>172</td><td><code><pre>    if err != nil {</pre></code></td></tr><tr><td>173</td><td><code><pre>        return false</pre></code></td></tr><tr><td>174</td><td><code><pre>    }</pre></code></td></tr><tr><td>175</td><td><code><pre></pre></code></td></tr><tr><td>176</td><td><code><pre>    /*</pre></code></td></tr><tr><td>177</td><td><code><pre>        Return true if the number of bytes written matches the data length.</pre></code></td></tr><tr><td>178</td><td><code><pre>    */</pre></code></td></tr><tr><td>179</td><td><code><pre></pre></code></td></tr><tr><td>180</td><td><code><pre>    return writen == len(data)</pre></code></td></tr><tr><td>181</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_CreateRequest">func CreateRequest</div><div class="info"><a href="#s_fn_CreateRequest">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/request.go</code>:</p></div><table class="listing">
<tr><td>22</td><td><code><pre>func CreateRequest(raw *http.Request) (*Request) {</pre></code></td></tr><tr><td>23</td><td><code><pre></pre></code></td></tr><tr><td>24</td><td><code><pre>    /*</pre></code></td></tr><tr><td>25</td><td><code><pre>        Create a new Request.</pre></code></td></tr><tr><td>26</td><td><code><pre>    */</pre></code></td></tr><tr><td>27</td><td><code><pre></pre></code></td></tr><tr><td>28</td><td><code><pre>    req := new(Request)</pre></code></td></tr><tr><td>29</td><td><code><pre></pre></code></td></tr><tr><td>30</td><td><code><pre>    /*</pre></code></td></tr><tr><td>31</td><td><code><pre>        Set the source http.Request so it can be accessed later.</pre></code></td></tr><tr><td>32</td><td><code><pre>    */</pre></code></td></tr><tr><td>33</td><td><code><pre></pre></code></td></tr><tr><td>34</td><td><code><pre>    req.Raw = raw</pre></code></td></tr><tr><td>35</td><td><code><pre></pre></code></td></tr><tr><td>36</td><td><code><pre>    /*</pre></code></td></tr><tr><td>37</td><td><code><pre>        Set the Url for easy access.</pre></code></td></tr><tr><td>38</td><td><code><pre></pre></code></td></tr><tr><td>39</td><td><code><pre>        Note: this value may be changed by the stack.handle() function.</pre></code></td></tr><tr><td>40</td><td><code><pre>    */</pre></code></td></tr><tr><td>41</td><td><code><pre></pre></code></td></tr><tr><td>42</td><td><code><pre>    req.Url = raw.RequestURI</pre></code></td></tr><tr><td>43</td><td><code><pre></pre></code></td></tr><tr><td>44</td><td><code><pre>    /*</pre></code></td></tr><tr><td>45</td><td><code><pre>        Set the Url for easy access.</pre></code></td></tr><tr><td>46</td><td><code><pre></pre></code></td></tr><tr><td>47</td><td><code><pre>        Note: this value should never change over the life time of the request.</pre></code></td></tr><tr><td>48</td><td><code><pre>    */</pre></code></td></tr><tr><td>49</td><td><code><pre></pre></code></td></tr><tr><td>50</td><td><code><pre>    req.OriginalUrl = raw.RequestURI</pre></code></td></tr><tr><td>51</td><td><code><pre></pre></code></td></tr><tr><td>52</td><td><code><pre>    /*</pre></code></td></tr><tr><td>53</td><td><code><pre>        Return the finished stack.Request.</pre></code></td></tr><tr><td>54</td><td><code><pre>    */</pre></code></td></tr><tr><td>55</td><td><code><pre></pre></code></td></tr><tr><td>56</td><td><code><pre>    return req</pre></code></td></tr><tr><td>57</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.SetHeaders">func Response.SetHeaders</div><div class="info"><a href="#s_fn_Response.SetHeaders">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/response.go</code>:</p></div><table class="listing">
<tr><td>55</td><td><code><pre>func (this *Response) SetHeaders(headers map[string]string) (bool) {</pre></code></td></tr><tr><td>56</td><td><code><pre>    for key, value := range headers {</pre></code></td></tr><tr><td>57</td><td><code><pre>        if this.SetHeader(key, value) == false {</pre></code></td></tr><tr><td>58</td><td><code><pre>            return false</pre></code></td></tr><tr><td>59</td><td><code><pre>        }</pre></code></td></tr><tr><td>60</td><td><code><pre>    }</pre></code></td></tr><tr><td>61</td><td><code><pre>    return true</pre></code></td></tr><tr><td>62</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.SetHeader">func Response.SetHeader</div><div class="info"><a href="#s_fn_Response.SetHeader">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/response.go</code>:</p></div><table class="listing">
<tr><td>70</td><td><code><pre>func (this *Response) SetHeader(key string, value string) (bool) {</pre></code></td></tr><tr><td>71</td><td><code><pre></pre></code></td></tr><tr><td>72</td><td><code><pre>    /*</pre></code></td></tr><tr><td>73</td><td><code><pre>        If the headers have been sent nothing can be done so return false.</pre></code></td></tr><tr><td>74</td><td><code><pre>    */</pre></code></td></tr><tr><td>75</td><td><code><pre></pre></code></td></tr><tr><td>76</td><td><code><pre>    if this.HeaderSent == true {</pre></code></td></tr><tr><td>77</td><td><code><pre>        return false</pre></code></td></tr><tr><td>78</td><td><code><pre>    }</pre></code></td></tr><tr><td>79</td><td><code><pre></pre></code></td></tr><tr><td>80</td><td><code><pre>    /*</pre></code></td></tr><tr><td>81</td><td><code><pre>        http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2</pre></code></td></tr><tr><td>82</td><td><code><pre>        Message headers are case-insensitive so they are forced to lower case.</pre></code></td></tr><tr><td>83</td><td><code><pre>    */</pre></code></td></tr><tr><td>84</td><td><code><pre></pre></code></td></tr><tr><td>85</td><td><code><pre>    this.Writer.Header().Set(strings.ToLower(key), value)</pre></code></td></tr><tr><td>86</td><td><code><pre></pre></code></td></tr><tr><td>87</td><td><code><pre>    /*</pre></code></td></tr><tr><td>88</td><td><code><pre>        The header was set so return true.</pre></code></td></tr><tr><td>89</td><td><code><pre>    */</pre></code></td></tr><tr><td>90</td><td><code><pre></pre></code></td></tr><tr><td>91</td><td><code><pre>    return true</pre></code></td></tr><tr><td>92</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_CreateResponse">func CreateResponse</div><div class="info"><a href="#s_fn_CreateResponse">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/response.go</code>:</p></div><table class="listing">
<tr><td>24</td><td><code><pre>func CreateResponse(writer http.ResponseWriter) (*Response) {</pre></code></td></tr><tr><td>25</td><td><code><pre></pre></code></td></tr><tr><td>26</td><td><code><pre>    /*</pre></code></td></tr><tr><td>27</td><td><code><pre>        Create a new Response.</pre></code></td></tr><tr><td>28</td><td><code><pre>    */</pre></code></td></tr><tr><td>29</td><td><code><pre></pre></code></td></tr><tr><td>30</td><td><code><pre>    this := new(Response)</pre></code></td></tr><tr><td>31</td><td><code><pre></pre></code></td></tr><tr><td>32</td><td><code><pre>    /*</pre></code></td></tr><tr><td>33</td><td><code><pre>        Set the source http.ResponseWriter so it can be accessed later.</pre></code></td></tr><tr><td>34</td><td><code><pre>    */</pre></code></td></tr><tr><td>35</td><td><code><pre></pre></code></td></tr><tr><td>36</td><td><code><pre>    this.Writer = writer</pre></code></td></tr><tr><td>37</td><td><code><pre></pre></code></td></tr><tr><td>38</td><td><code><pre>    /*</pre></code></td></tr><tr><td>39</td><td><code><pre>        Set a default status code.</pre></code></td></tr><tr><td>40</td><td><code><pre>    */</pre></code></td></tr><tr><td>41</td><td><code><pre></pre></code></td></tr><tr><td>42</td><td><code><pre>    this.StatusCode = 200</pre></code></td></tr><tr><td>43</td><td><code><pre></pre></code></td></tr><tr><td>44</td><td><code><pre>    /*</pre></code></td></tr><tr><td>45</td><td><code><pre>        Return the finished stack.Response.</pre></code></td></tr><tr><td>46</td><td><code><pre>    */</pre></code></td></tr><tr><td>47</td><td><code><pre></pre></code></td></tr><tr><td>48</td><td><code><pre>    return this</pre></code></td></tr><tr><td>49</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.End">func Response.End</div><div class="info"><a href="#s_fn_Response.End">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/response.go</code>:</p></div><table class="listing">
<tr><td>187</td><td><code><pre>func (this *Response) End(data string) (bool) {</pre></code></td></tr><tr><td>188</td><td><code><pre></pre></code></td></tr><tr><td>189</td><td><code><pre>    /*</pre></code></td></tr><tr><td>190</td><td><code><pre>        Write the data to the client.</pre></code></td></tr><tr><td>191</td><td><code><pre>    */</pre></code></td></tr><tr><td>192</td><td><code><pre></pre></code></td></tr><tr><td>193</td><td><code><pre>    status := this.Write(data)</pre></code></td></tr><tr><td>194</td><td><code><pre></pre></code></td></tr><tr><td>195</td><td><code><pre>    /*</pre></code></td></tr><tr><td>196</td><td><code><pre>        Set the &#34;Closed&#34; flag to true.</pre></code></td></tr><tr><td>197</td><td><code><pre>    */</pre></code></td></tr><tr><td>198</td><td><code><pre></pre></code></td></tr><tr><td>199</td><td><code><pre>    this.Closed = true</pre></code></td></tr><tr><td>200</td><td><code><pre></pre></code></td></tr><tr><td>201</td><td><code><pre>    /*</pre></code></td></tr><tr><td>202</td><td><code><pre>        Return the status of the write operation.</pre></code></td></tr><tr><td>203</td><td><code><pre>    */</pre></code></td></tr><tr><td>204</td><td><code><pre></pre></code></td></tr><tr><td>205</td><td><code><pre>    return status</pre></code></td></tr><tr><td>206</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Response.writeHeaders">func Response.writeHeaders</div><div class="info"><a href="#s_fn_Response.writeHeaders">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/response.go</code>:</p></div><table class="listing">
<tr><td>98</td><td><code><pre>func (this *Response) writeHeaders() {</pre></code></td></tr><tr><td>99</td><td><code><pre></pre></code></td></tr><tr><td>100</td><td><code><pre>    /*</pre></code></td></tr><tr><td>101</td><td><code><pre>        Set the HeaderSent flag to true.</pre></code></td></tr><tr><td>102</td><td><code><pre>    */</pre></code></td></tr><tr><td>103</td><td><code><pre></pre></code></td></tr><tr><td>104</td><td><code><pre>    this.HeaderSent = true</pre></code></td></tr><tr><td>105</td><td><code><pre></pre></code></td></tr><tr><td>106</td><td><code><pre>    /*</pre></code></td></tr><tr><td>107</td><td><code><pre>        Write the headers with the current StatusCode.</pre></code></td></tr><tr><td>108</td><td><code><pre>    */</pre></code></td></tr><tr><td>109</td><td><code><pre></pre></code></td></tr><tr><td>110</td><td><code><pre>    this.Writer.WriteHeader(this.StatusCode);</pre></code></td></tr><tr><td>111</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_CreateServer">func CreateServer</div><div class="info"><a href="#s_fn_CreateServer">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/connect.go</code>:</p></div><table class="listing">
<tr><td>22</td><td><code><pre>func CreateServer() (*Server) {</pre></code></td></tr><tr><td>23</td><td><code><pre>    return new(Server)</pre></code></td></tr><tr><td>24</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Favicon">func Favicon</div><div class="info"><a href="#s_fn_Favicon">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/favicon.go</code>:</p></div><table class="listing">
<tr><td>45</td><td><code><pre>func Favicon(opt FavOpt) (func(req *Request, res *Response, next func())) {</pre></code></td></tr><tr><td>46</td><td><code><pre></pre></code></td></tr><tr><td>47</td><td><code><pre>    /*</pre></code></td></tr><tr><td>48</td><td><code><pre>        Create an Icon.</pre></code></td></tr><tr><td>49</td><td><code><pre>    */</pre></code></td></tr><tr><td>50</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>51</td><td><code><pre>    type Icon struct {</pre></code></td></tr><tr><td>52</td><td><code><pre>        headers map[string]string</pre></code></td></tr><tr><td>53</td><td><code><pre>        body []byte</pre></code></td></tr><tr><td>54</td><td><code><pre>    }</pre></code></td></tr><tr><td>55</td><td><code><pre></pre></code></td></tr><tr><td>56</td><td><code><pre>    /*</pre></code></td></tr><tr><td>57</td><td><code><pre>        Create a new map.</pre></code></td></tr><tr><td>58</td><td><code><pre>    */</pre></code></td></tr><tr><td>59</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>60</td><td><code><pre>    icon := Icon{</pre></code></td></tr><tr><td>61</td><td><code><pre>        headers: make(map[string]string),</pre></code></td></tr><tr><td>62</td><td><code><pre>    }</pre></code></td></tr><tr><td>63</td><td><code><pre></pre></code></td></tr><tr><td>64</td><td><code><pre>    /*</pre></code></td></tr><tr><td>65</td><td><code><pre>        Set the default maxAge.</pre></code></td></tr><tr><td>66</td><td><code><pre>    */</pre></code></td></tr><tr><td>67</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>68</td><td><code><pre>    maxAge := 86400000</pre></code></td></tr><tr><td>69</td><td><code><pre></pre></code></td></tr><tr><td>70</td><td><code><pre>    /*</pre></code></td></tr><tr><td>71</td><td><code><pre>        If we were given a max age use it.</pre></code></td></tr><tr><td>72</td><td><code><pre>    */</pre></code></td></tr><tr><td>73</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>74</td><td><code><pre>    if opt.MaxAge &gt; 0 {</pre></code></td></tr><tr class="miss"><td>75</td><td><code><pre>        maxAge = opt.MaxAge</pre></code></td></tr><tr><td>76</td><td><code><pre>    }</pre></code></td></tr><tr><td>77</td><td><code><pre></pre></code></td></tr><tr><td>78</td><td><code><pre>    /*</pre></code></td></tr><tr><td>79</td><td><code><pre>        Set the default path.</pre></code></td></tr><tr><td>80</td><td><code><pre>    */</pre></code></td></tr><tr><td>81</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>82</td><td><code><pre>    path := &#34;./favicon.ico&#34;</pre></code></td></tr><tr><td>83</td><td><code><pre></pre></code></td></tr><tr><td>84</td><td><code><pre>    /*</pre></code></td></tr><tr><td>85</td><td><code><pre>        If we were given a path use it.</pre></code></td></tr><tr><td>86</td><td><code><pre>    */</pre></code></td></tr><tr><td>87</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>88</td><td><code><pre>    if len(opt.Path) &gt; 0 {</pre></code></td></tr><tr class="miss"><td>89</td><td><code><pre>        path = opt.Path</pre></code></td></tr><tr><td>90</td><td><code><pre>    }</pre></code></td></tr><tr><td>91</td><td><code><pre></pre></code></td></tr><tr><td>92</td><td><code><pre>    /*</pre></code></td></tr><tr><td>93</td><td><code><pre>        The handler function returned to Use().</pre></code></td></tr><tr><td>94</td><td><code><pre>    */</pre></code></td></tr><tr><td>95</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>96</td><td><code><pre>    return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>97</td><td><code><pre></pre></code></td></tr><tr><td>98</td><td><code><pre>        /*</pre></code></td></tr><tr><td>99</td><td><code><pre>            If this is not a fav icon return fast</pre></code></td></tr><tr><td>100</td><td><code><pre>        */</pre></code></td></tr><tr><td>101</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>102</td><td><code><pre>        if req.Url != &#34;/favicon.ico&#34; {</pre></code></td></tr><tr class="miss"><td>103</td><td><code><pre>            return</pre></code></td></tr><tr><td>104</td><td><code><pre>        }</pre></code></td></tr><tr><td>105</td><td><code><pre></pre></code></td></tr><tr><td>106</td><td><code><pre>        /*</pre></code></td></tr><tr><td>107</td><td><code><pre>            If we have the icon cached, serve it.</pre></code></td></tr><tr><td>108</td><td><code><pre>        */</pre></code></td></tr><tr><td>109</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>110</td><td><code><pre>        if len(icon.body) &gt; 0 {</pre></code></td></tr><tr class="miss"><td>111</td><td><code><pre>            res.SetHeaders(icon.headers)</pre></code></td></tr><tr class="miss"><td>112</td><td><code><pre>            res.WriteBytes(icon.body)</pre></code></td></tr><tr class="miss"><td>113</td><td><code><pre>            res.End(&#34;&#34;);</pre></code></td></tr><tr class="miss"><td>114</td><td><code><pre>            return</pre></code></td></tr><tr><td>115</td><td><code><pre>        }</pre></code></td></tr><tr><td>116</td><td><code><pre></pre></code></td></tr><tr><td>117</td><td><code><pre>        /*</pre></code></td></tr><tr><td>118</td><td><code><pre>            Otherwise read the icon into cache.</pre></code></td></tr><tr><td>119</td><td><code><pre>        */</pre></code></td></tr><tr><td>120</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>121</td><td><code><pre>        buf, err := ioutil.ReadFile(path)</pre></code></td></tr><tr class="miss"><td>122</td><td><code><pre>        if err != nil {</pre></code></td></tr><tr class="miss"><td>123</td><td><code><pre>            return</pre></code></td></tr><tr><td>124</td><td><code><pre>        }</pre></code></td></tr><tr><td>125</td><td><code><pre></pre></code></td></tr><tr><td>126</td><td><code><pre>        /*</pre></code></td></tr><tr><td>127</td><td><code><pre>            Generate an MD5 of the icon to be used in the etag.</pre></code></td></tr><tr><td>128</td><td><code><pre>        */</pre></code></td></tr><tr><td>129</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>130</td><td><code><pre>        hasher := md5.New()</pre></code></td></tr><tr class="miss"><td>131</td><td><code><pre>        io.WriteString(hasher, fmt.Sprint(buf))</pre></code></td></tr><tr><td>132</td><td><code><pre></pre></code></td></tr><tr><td>133</td><td><code><pre>        /*</pre></code></td></tr><tr><td>134</td><td><code><pre>            Create headers for the icon.</pre></code></td></tr><tr><td>135</td><td><code><pre>        */</pre></code></td></tr><tr><td>136</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>137</td><td><code><pre>        icon.headers[&#34;content-type&#34;] = &#34;image/x-icon&#34;</pre></code></td></tr><tr class="miss"><td>138</td><td><code><pre>        icon.headers[&#34;content-length&#34;] = fmt.Sprint(len(buf))</pre></code></td></tr><tr class="miss"><td>139</td><td><code><pre>        icon.headers[&#34;etag&#34;] = fmt.Sprint(hasher.Sum(nil))</pre></code></td></tr><tr class="miss"><td>140</td><td><code><pre>        icon.headers[&#34;cache-control&#34;] = &#34;public, max-age=&#34; + fmt.Sprint(maxAge / 1000)</pre></code></td></tr><tr class="miss"><td>141</td><td><code><pre>        icon.body = buf</pre></code></td></tr><tr><td>142</td><td><code><pre></pre></code></td></tr><tr><td>143</td><td><code><pre>        /*</pre></code></td></tr><tr><td>144</td><td><code><pre>            Serve the icon.</pre></code></td></tr><tr><td>145</td><td><code><pre>        */</pre></code></td></tr><tr><td>146</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>147</td><td><code><pre>        res.SetHeaders(icon.headers)</pre></code></td></tr><tr class="miss"><td>148</td><td><code><pre>        res.WriteBytes(icon.body)</pre></code></td></tr><tr class="miss"><td>149</td><td><code><pre>        res.End(&#34;&#34;);</pre></code></td></tr><tr><td>150</td><td><code><pre>    }</pre></code></td></tr><tr><td>151</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_loggerFormatDev">func loggerFormatDev</div><div class="info"><a href="#s_fn_loggerFormatDev">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/logger.go</code>:</p></div><table class="listing">
<tr><td>126</td><td><code><pre>func loggerFormatDev(opt LogOpt, req *Request, res *Response) (string) {</pre></code></td></tr><tr><td>127</td><td><code><pre></pre></code></td></tr><tr><td>128</td><td><code><pre>    /*</pre></code></td></tr><tr><td>129</td><td><code><pre>        Get the time taken in milliseconds.</pre></code></td></tr><tr><td>130</td><td><code><pre>    */</pre></code></td></tr><tr><td>131</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>132</td><td><code><pre>    totalTime := (time.Now().UnixNano() - opt.startTime) / 1000000</pre></code></td></tr><tr><td>133</td><td><code><pre></pre></code></td></tr><tr><td>134</td><td><code><pre>    /*</pre></code></td></tr><tr><td>135</td><td><code><pre>        Get the status code for the request.</pre></code></td></tr><tr><td>136</td><td><code><pre>    */</pre></code></td></tr><tr><td>137</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>138</td><td><code><pre>    status := res.StatusCode</pre></code></td></tr><tr><td>139</td><td><code><pre></pre></code></td></tr><tr><td>140</td><td><code><pre>    /*</pre></code></td></tr><tr><td>141</td><td><code><pre>        Get the length of the data sent.</pre></code></td></tr><tr><td>142</td><td><code><pre>    */</pre></code></td></tr><tr><td>143</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>144</td><td><code><pre>    length, _ := strconv.Atoi(res.Writer.Header().Get(&#34;content-length&#34;))</pre></code></td></tr><tr><td>145</td><td><code><pre></pre></code></td></tr><tr><td>146</td><td><code><pre>    /*</pre></code></td></tr><tr><td>147</td><td><code><pre>        The length as a string.</pre></code></td></tr><tr><td>148</td><td><code><pre>    */</pre></code></td></tr><tr><td>149</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>150</td><td><code><pre>    strLen := &#34;&#34;</pre></code></td></tr><tr><td>151</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>152</td><td><code><pre>    if length &gt; 0 {</pre></code></td></tr><tr class="miss"><td>153</td><td><code><pre>        strLen = &#34; - &#34; + fmt.Sprint(length);</pre></code></td></tr><tr><td>154</td><td><code><pre>    }</pre></code></td></tr><tr><td>155</td><td><code><pre></pre></code></td></tr><tr><td>156</td><td><code><pre>    /*</pre></code></td></tr><tr><td>157</td><td><code><pre>        Set the default color for the log.</pre></code></td></tr><tr><td>158</td><td><code><pre>    */</pre></code></td></tr><tr><td>159</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>160</td><td><code><pre>    color := 32</pre></code></td></tr><tr><td>161</td><td><code><pre></pre></code></td></tr><tr><td>162</td><td><code><pre>    /*</pre></code></td></tr><tr><td>163</td><td><code><pre>        Pick a color for the log.</pre></code></td></tr><tr><td>164</td><td><code><pre>    */</pre></code></td></tr><tr><td>165</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>166</td><td><code><pre>    switch {</pre></code></td></tr><tr><td>167</td><td><code><pre>    case status &gt;= 500:</pre></code></td></tr><tr class="miss"><td>168</td><td><code><pre>        color = 31</pre></code></td></tr><tr><td>169</td><td><code><pre>    case status &gt;= 400:</pre></code></td></tr><tr class="miss"><td>170</td><td><code><pre>        color = 33</pre></code></td></tr><tr><td>171</td><td><code><pre>    case status &gt;= 300:</pre></code></td></tr><tr class="miss"><td>172</td><td><code><pre>        color = 36</pre></code></td></tr><tr><td>173</td><td><code><pre>    }</pre></code></td></tr><tr><td>174</td><td><code><pre></pre></code></td></tr><tr><td>175</td><td><code><pre>    /*</pre></code></td></tr><tr><td>176</td><td><code><pre>        Build the log line.</pre></code></td></tr><tr><td>177</td><td><code><pre>    */</pre></code></td></tr><tr><td>178</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>179</td><td><code><pre>    log := &#34;\x1b[90m&#34; + req.Raw.Method</pre></code></td></tr><tr class="miss"><td>180</td><td><code><pre>    log += &#34; &#34; + req.OriginalUrl + &#34; &#34;</pre></code></td></tr><tr class="miss"><td>181</td><td><code><pre>    log += &#34;\x1b[&#34; + fmt.Sprint(color) + &#34;m&#34; + fmt.Sprint(status)</pre></code></td></tr><tr class="miss"><td>182</td><td><code><pre>    log += &#34; \x1b[90m&#34;</pre></code></td></tr><tr class="miss"><td>183</td><td><code><pre>    log += fmt.Sprint(totalTime)</pre></code></td></tr><tr class="miss"><td>184</td><td><code><pre>    log += &#34;ms&#34; + strLen</pre></code></td></tr><tr class="miss"><td>185</td><td><code><pre>    log += &#34;\x1b[0m&#34;</pre></code></td></tr><tr><td>186</td><td><code><pre></pre></code></td></tr><tr><td>187</td><td><code><pre>    /*</pre></code></td></tr><tr><td>188</td><td><code><pre>        Return the log string.</pre></code></td></tr><tr><td>189</td><td><code><pre>    */</pre></code></td></tr><tr><td>190</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>191</td><td><code><pre>    return log</pre></code></td></tr><tr><td>192</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Static">func Static</div><div class="info"><a href="#s_fn_Static">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/static.go</code>:</p></div><table class="listing">
<tr><td>41</td><td><code><pre>func Static(opt StaticOpt) (func(req *Request, res *Response, next func())) {</pre></code></td></tr><tr><td>42</td><td><code><pre></pre></code></td></tr><tr><td>43</td><td><code><pre>    /*</pre></code></td></tr><tr><td>44</td><td><code><pre>        The default loction of static files.</pre></code></td></tr><tr><td>45</td><td><code><pre>    */</pre></code></td></tr><tr><td>46</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>47</td><td><code><pre>    root := &#34;./static&#34;</pre></code></td></tr><tr><td>48</td><td><code><pre></pre></code></td></tr><tr><td>49</td><td><code><pre>    /*</pre></code></td></tr><tr><td>50</td><td><code><pre>        If we were given a root use it.</pre></code></td></tr><tr><td>51</td><td><code><pre>    */</pre></code></td></tr><tr><td>52</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>53</td><td><code><pre>    if len(opt.Root) &gt; 0 {</pre></code></td></tr><tr class="miss"><td>54</td><td><code><pre>        root = opt.Root</pre></code></td></tr><tr><td>55</td><td><code><pre>    }</pre></code></td></tr><tr><td>56</td><td><code><pre></pre></code></td></tr><tr><td>57</td><td><code><pre>    /*</pre></code></td></tr><tr><td>58</td><td><code><pre>        Create a http.FileServer to server the files.</pre></code></td></tr><tr><td>59</td><td><code><pre>    */</pre></code></td></tr><tr><td>60</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>61</td><td><code><pre>    fileServer := http.FileServer(http.Dir(root))</pre></code></td></tr><tr><td>62</td><td><code><pre></pre></code></td></tr><tr><td>63</td><td><code><pre>    /*</pre></code></td></tr><tr><td>64</td><td><code><pre>        Return the handle function.</pre></code></td></tr><tr><td>65</td><td><code><pre>    */</pre></code></td></tr><tr><td>66</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>67</td><td><code><pre>    return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>68</td><td><code><pre></pre></code></td></tr><tr><td>69</td><td><code><pre>        /*</pre></code></td></tr><tr><td>70</td><td><code><pre>            Because http.FileServer serves directories and it&#39;s own 404 we </pre></code></td></tr><tr><td>71</td><td><code><pre>            want to see if the file is really there before we hand of to it.</pre></code></td></tr><tr><td>72</td><td><code><pre>            To do that we see if the file exists. If it doesn&#39;t, then we return quickly.</pre></code></td></tr><tr><td>73</td><td><code><pre></pre></code></td></tr><tr><td>74</td><td><code><pre>            Question: Is this not really expensive?</pre></code></td></tr><tr><td>75</td><td><code><pre>            Answer: It&#39;s not ideal. Writing a custom static server is on the todo list.</pre></code></td></tr><tr><td>76</td><td><code><pre>        */</pre></code></td></tr><tr><td>77</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>78</td><td><code><pre>        if _, err := os.Stat(root + req.Url); os.IsNotExist(err) {</pre></code></td></tr><tr class="miss"><td>79</td><td><code><pre>            return</pre></code></td></tr><tr><td>80</td><td><code><pre>        }</pre></code></td></tr><tr><td>81</td><td><code><pre></pre></code></td></tr><tr><td>82</td><td><code><pre>        /*</pre></code></td></tr><tr><td>83</td><td><code><pre>            If we have to serve a file strip the matched Url and call ServeHTTP() on the fileServer.</pre></code></td></tr><tr><td>84</td><td><code><pre>        */</pre></code></td></tr><tr><td>85</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>86</td><td><code><pre>        http.StripPrefix(req.MatchedUrl, fileServer).ServeHTTP(res.Writer, req.Raw)</pre></code></td></tr><tr><td>87</td><td><code><pre></pre></code></td></tr><tr><td>88</td><td><code><pre>        /*</pre></code></td></tr><tr><td>89</td><td><code><pre>            Now call End() to make sure we don&#39;t process any more middleware.</pre></code></td></tr><tr><td>90</td><td><code><pre>        */</pre></code></td></tr><tr><td>91</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>92</td><td><code><pre>        res.End(&#34;&#34;)</pre></code></td></tr><tr><td>93</td><td><code><pre>    }</pre></code></td></tr><tr><td>94</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Logger">func Logger</div><div class="info"><a href="#s_fn_Logger">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/logger.go</code>:</p></div><table class="listing">
<tr><td>74</td><td><code><pre>func Logger(opt LogOpt) (func(req *Request, res *Response, next func())) {</pre></code></td></tr><tr><td>75</td><td><code><pre></pre></code></td></tr><tr><td>76</td><td><code><pre>    /*</pre></code></td></tr><tr><td>77</td><td><code><pre>        Output on request instead of response.</pre></code></td></tr><tr><td>78</td><td><code><pre>    */</pre></code></td></tr><tr><td>79</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>80</td><td><code><pre>    immediate := opt.Immediate</pre></code></td></tr><tr><td>81</td><td><code><pre></pre></code></td></tr><tr><td>82</td><td><code><pre>    /*</pre></code></td></tr><tr><td>83</td><td><code><pre>        Return the handler function.</pre></code></td></tr><tr><td>84</td><td><code><pre>    */</pre></code></td></tr><tr><td>85</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>86</td><td><code><pre>    return func(req *Request, res *Response, next func()) {</pre></code></td></tr><tr><td>87</td><td><code><pre></pre></code></td></tr><tr><td>88</td><td><code><pre>        /*</pre></code></td></tr><tr><td>89</td><td><code><pre>            Grab the start time.</pre></code></td></tr><tr><td>90</td><td><code><pre>        */</pre></code></td></tr><tr><td>91</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>92</td><td><code><pre>        opt.startTime = time.Now().UnixNano()</pre></code></td></tr><tr><td>93</td><td><code><pre></pre></code></td></tr><tr><td>94</td><td><code><pre>        /*</pre></code></td></tr><tr><td>95</td><td><code><pre>            If we are to log at the end of the request call next() now.</pre></code></td></tr><tr><td>96</td><td><code><pre>        */</pre></code></td></tr><tr><td>97</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>98</td><td><code><pre>        if immediate != true {</pre></code></td></tr><tr><td>99</td><td><code><pre></pre></code></td></tr><tr><td>100</td><td><code><pre>            /*</pre></code></td></tr><tr><td>101</td><td><code><pre>                Once all the other middleware has run, execution</pre></code></td></tr><tr><td>102</td><td><code><pre>                will come back to this point and continue.</pre></code></td></tr><tr><td>103</td><td><code><pre>            */</pre></code></td></tr><tr><td>104</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>105</td><td><code><pre>            next()</pre></code></td></tr><tr><td>106</td><td><code><pre>        }</pre></code></td></tr><tr><td>107</td><td><code><pre></pre></code></td></tr><tr><td>108</td><td><code><pre>        /*</pre></code></td></tr><tr><td>109</td><td><code><pre>            Format the log string requested (only dev at the moment).</pre></code></td></tr><tr><td>110</td><td><code><pre>        */</pre></code></td></tr><tr><td>111</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>112</td><td><code><pre>        line := loggerFormatDev(opt, req, res)</pre></code></td></tr><tr><td>113</td><td><code><pre></pre></code></td></tr><tr><td>114</td><td><code><pre>        /*</pre></code></td></tr><tr><td>115</td><td><code><pre>            Print the log to standard output.</pre></code></td></tr><tr><td>116</td><td><code><pre>        */</pre></code></td></tr><tr><td>117</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>118</td><td><code><pre>        fmt.Println(line)</pre></code></td></tr><tr><td>119</td><td><code><pre>    }</pre></code></td></tr><tr><td>120</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Server.ListenTLS">func Server.ListenTLS</div><div class="info"><a href="#s_fn_Server.ListenTLS">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/connect.go</code>:</p></div><table class="listing">
<tr><td>203</td><td><code><pre>func (this *Server) ListenTLS(port int, certFile string, keyFile string) {</pre></code></td></tr><tr><td>204</td><td><code><pre></pre></code></td></tr><tr><td>205</td><td><code><pre>    /*</pre></code></td></tr><tr><td>206</td><td><code><pre>        Set the address to run on.</pre></code></td></tr><tr><td>207</td><td><code><pre>    */</pre></code></td></tr><tr><td>208</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>209</td><td><code><pre>    address := &#34;:&#34; + fmt.Sprint(port)</pre></code></td></tr><tr><td>210</td><td><code><pre>    </pre></code></td></tr><tr><td>211</td><td><code><pre>    /*</pre></code></td></tr><tr><td>212</td><td><code><pre>        Start the server.</pre></code></td></tr><tr><td>213</td><td><code><pre>    */</pre></code></td></tr><tr><td>214</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>215</td><td><code><pre>    log.Fatal(http.ListenAndServeTLS(address, certFile, keyFile, createHttpHandler(this)))</pre></code></td></tr><tr><td>216</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Server.Listen">func Server.Listen</div><div class="info"><a href="#s_fn_Server.Listen">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/connect.go</code>:</p></div><table class="listing">
<tr><td>184</td><td><code><pre>func (this *Server) Listen(port int) {</pre></code></td></tr><tr><td>185</td><td><code><pre></pre></code></td></tr><tr><td>186</td><td><code><pre>    /*</pre></code></td></tr><tr><td>187</td><td><code><pre>        Set the address to run on.</pre></code></td></tr><tr><td>188</td><td><code><pre>    */</pre></code></td></tr><tr><td>189</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>190</td><td><code><pre>    address := &#34;:&#34; + fmt.Sprint(port)</pre></code></td></tr><tr><td>191</td><td><code><pre></pre></code></td></tr><tr><td>192</td><td><code><pre>    /*</pre></code></td></tr><tr><td>193</td><td><code><pre>        Start the server.</pre></code></td></tr><tr><td>194</td><td><code><pre>    */</pre></code></td></tr><tr><td>195</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>196</td><td><code><pre>    log.Fatal(http.ListenAndServe(address, createHttpHandler(this)))</pre></code></td></tr><tr><td>197</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_Handler.ServeHTTP">func Handler.ServeHTTP</div><div class="info"><a href="#s_fn_Handler.ServeHTTP">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/http.go</code>:</p></div><table class="listing">
<tr><td>27</td><td><code><pre>func (this *Handler) ServeHTTP(res http.ResponseWriter, req *http.Request) {</pre></code></td></tr><tr><td>28</td><td><code><pre></pre></code></td></tr><tr><td>29</td><td><code><pre>    /*</pre></code></td></tr><tr><td>30</td><td><code><pre>        Pass the res and req into there repective create functions.</pre></code></td></tr><tr><td>31</td><td><code><pre>        The results of these are then passed to stack.server.handle().</pre></code></td></tr><tr><td>32</td><td><code><pre>    */</pre></code></td></tr><tr><td>33</td><td><code><pre></pre></code></td></tr><tr class="miss"><td>34</td><td><code><pre>    this.server.handle(CreateRequest(req), CreateResponse(res), 0)</pre></code></td></tr><tr><td>35</td><td><code><pre>}</pre></code></td></tr></table>

<div class="funcname" id="fn_createHttpHandler">func createHttpHandler</div><div class="info"><a href="#s_fn_createHttpHandler">Back</a><p>In <code>/Users/allinson/Go/src/github.com/ricallinson/stack/http.go</code>:</p></div><table class="listing">
<tr><td>19</td><td><code><pre>func createHttpHandler(server *Server) http.Handler {</pre></code></td></tr><tr class="miss"><td>20</td><td><code><pre>    return &amp;Handler{server: server}</pre></code></td></tr><tr><td>21</td><td><code><pre>}</pre></code></td></tr></table>
<script type="text/javascript">
document.getElementById("totalcov").textContent = "47.76%"
</script>
<!-- Can be parsed by external script
PACKAGE:github.com/ricallinson/stack DONE:47.76
-->

    </body>
</html>
